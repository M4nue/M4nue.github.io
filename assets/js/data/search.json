[
  
  {
    "title": "Guia Completa Gns3 Wireshark copy",
    "url": "/posts/guia-completa-gns3-wireshark-copy/",
    "categories": "",
    "tags": "",
    "date": "2025-10-20 00:00:00 +0200",
    "content": "ÍNDICE  [INSTALACIÓN GNS3 DEBIAN 122]  [Creación de un entorno virtual y activación de este3]  [Instalación de paquetes requeridos para python4]  [Importar maquina GNS3 VM5]  [Iniciar la interfaz gráfica7]  [Escenario10]  [INSTALACIÓN WIRESHARK DEBIAN 1212]  [INSTALACIÓN GNS3 EN WINDOWS13]  [Escenario26]  [Instalación GNS3 VM28]  [INSTALACIÓN WIRESHARK WINDOWS30]  [CAPTURA TRÁFICO DNS31]  [CAPTURA TRÁFICO DHCP32]  [SOLUCIÓN DE ERRORES32]  [DEBIAN32]  [Dynamips32]  [Start VPCS35]  [Ubridge36]  [Xterm38]  [Virbr039]  [Captura de tráfico wireshark41]  [Instalación VirtualBox42]  [WINDOWS43]  [No se encuentra la máquina GNS3 VM43]  [Indicar a GNS3 el uso de GNS3 VM43]  [BIBLIOGRAFÍA46]  INSTALACIÓN GNS3 DEBIAN 12  Antes de proceder con la instalación de los paquetes necesarios para instalar GNS3, debemos actualizar los de el sistema, para ello ejecutamos   sudo apt update  sudo apt list –upgradable (opcional, para ver los paquetes que se actualizarán)  sudo apt upgrade  Continuamos instalando los siguientes paquetes de python necesarios en debian  sudo apt install python3-pip python3-venv python3-pyqt5.qtsvg python3-pyqt5.qtwebsockets          python3-pip: Paquete que instala el gestor de paquetes pip           python3-venv: Librería de python que permite crear un entorno virtual           python3-pyqt5.qtsvg: Permite visionar archivos SVG (almacenan datos o imágenes en formato de puntos, líneas, curvas o formas de fórmulas matemáticas)           python3-pyqt5.qtsvg.websockets: Modulo que implementa tecnología websocket, esta es una tecnología web que permite la comunicación a través de canales TCP, éstos nos son necesarios para la comunicación entre el servidor y el cliente de GNS3      Una vez instalado, procederemos a realizar los siguientes pasos.          Creación de un entorno virtual y activación de este           Instalación de paquetes requeridos para python           Importar maquina GNS3 VM           Iniciar la interfaz gráfica      Creación de un entorno virtual y activación de este  Para crear un entorno virtual en python utilizaremos el siguiente comando  python3 -m venv gns3entorno  Para activarlo ejecutamos el siguiente comando  source gns3entorno/bin/activate  Notaremos que está activado debido al cambio en el prompt que cuenta con el nombre del entorno  De manera opcional en caso de querer desactivarlo, ejecutamos el comando:  deactivate  Notaremos que el prompt ha cambiado a como estaba anteriormente  Instalación de paquetes requeridos para python  Procederemos con la instalación de los siguientes paquetes de python  pip install pyqt5: Módulo que en este caso nos permitirá cargar la interfaz gráfica(GUI) de gns3, junto con tkinter son módulos utilizados en python para desarrollar GUI  pip install gns3-server: Software del servidor de GNS3  pip install gns3-gui: Interfaz gráfica de gns3  Importar maquina GNS3 VM  Para poder utilizar GNS3 VM necesitamos tener un Visualizador en este caso vamos a utilizar VirtualBox, si no se tiene instalado puede mirar la instalación en el apartado de [Instalación Virtualbox]  Primero necesitamos descargar un archivo .zip que contendrá la máquina virtual de GNS3 VM, podemos descargarlo desde el navegador o con el comando wget y el siguiente enlace   https://github.com/GNS3/gns3-gui/releases/download/v2.2.50/GNS3.VM.VirtualBox.2.2.50.zip   wget https://github.com/GNS3/gns3-gui/releases/download/v2.2.50/GNS3.VM.VirtualBox.2.2.50.zip  Descomprimimos el paquete .zip con la herramienta unzip  Ejecutamos VirtualBox he importamos el archivo .ova que hemos obtenido al descomprimir el .zip  Archivo &gt; importar servicio &gt; Archivo: Ruta_archivo_.ova  Después de pulsar en siguiente tenemos un resumen de las características de la maquina virtual  Finalmente esperar a que la máquina termine de importarse  Iniciar la interfaz gráfica  Iniciamos la interfaz ejecutando desde la línea de comandos y el entorno activado gns3 que debería a autocompletar el nombre al tabular  Al ejecutarlo por primera vez nos mostrará el Setup para saber que configuración tendrá este  En este apartado seleccionaremos utilizar GNS3 VM  En el siguiente apartado tenemos la ruta donde se almacenará el servidor, la cual la podemos cambiar, el host donde se almacena en este caso el propio equipo como marcamos antes y el puerto donde este se ejecutará con el protocolo TCP  Nos indica que la conexión ha sido exitosa  Después seleccionamos el Visualizador de virtualbox y seleccionar la máquina virtual de GNS3 VM  Nos muestra un resumen de la instalación antes de finalizar  Finalmente podemos ver que ya tenemos disponible GNS3 VM  Escenario  A continuación creamos un nuevo proyecto para montar un escenario de prueba pequeño, para ello pulsamos en:  File &gt; New blank project  Nombramos el proyecto y modificamos la ruta donde se guardarán el proyecta si lo deseamos  En este menú de la derecha podemos escoger los nodos a utilizar teniendo en los siguientes elementos:          routers           switches           Dispositivos finales (vpcs)           Dispositivos de seguridad           Conjunto de todos los elementos anteriores que tengamos disponibles           Y una opción para interconectar los nodos que pongamos en nuestros escenarios      Para colocar elementos en el escenario, simplemente los seleccionamos y los arrastramos  Ejecutamos y abrimos las terminales de los 2 VPCS, les asignamos una IP con el comando   ip Dirección_IP Gateway Mascara_de_Red  Comprobamos que ambos tienen conexión entre si con ping IP_destino  Si no nos acordamos de la ip de la máquina destino con el comando show ip veremos información del VPC en la cual se puede ver la ip con la máscara de este  INSTALACIÓN WIRESHARK DEBIAN 12  El paquete con el código fuente de este se encuentra en los repositorios de debian, por lo que primero deberíamos de actualizar el sistema en caso de que sea necesario.  sudo apt update  sudo apt upgrade  Instalaremos el paquete de wireshark  sudo apt install wireshark  Nos preguntará si deseamos instalar el paquete dumpcap de manera que todos los usuarios puedan capturar tráfico, en caso de indicar que no, si queremos que un usuario no privilegiado quiera capturar el tráfico, deberemos de añadirlo manualmente al grupo de wireshark   INSTALACIÓN GNS3 EN WINDOWS  Necesitamos obtener el ejecutable de GNS3 para ello nos dirigimos a la web oficial y logearnos o crear una cuenta   Una vez descargado el archivo .exe lo ejecutaremos, nos abrirá el setup y pulsaremos en next  A continuación nos mostrará los términos y condiciones, para continuar debemos de aceptarlos  Nos preguntará donde crear el directorio GNS3 para proceder con la instalación  Después indicaremos el tipo de instalación que necesitamos en este caso una instalación customizada y marcaremos la opción de GNS3 VM ya que la necesitaremos más adelante  Escogemos la ruta de instalación local  Escogemos el tipo de visualizador que vayamos a utilizar para GNS3 VM  Procederá con la instalación  En un momento dado durante la instalación, GNS3 nos ejecutará otra para poder avanzar, procederemos con la instalación de winpcap, necesario para la captura de paquetes en los escenarios que montemos  Al continuar aceptaremos los términos de winpcap  A continuación nos dará la opción de iniciar el controlador de winpcap en el arranque del equipo, lo marcamos  Después de eso finalizará la instalación de winpcap  Después de está procederá con la instalación de nmap  Después de aceptar los términos nos mostrará las opciones de instalación de nmap  Después procederá con la instalación y finalización de nmap  Después de nmap procederemos con la instalación de una herramienta de la empresa SolarWinds, traceroute NG (traceNG), este software cuenta con las siguientes características:          Detecta cambios de ruta           Permite sondeo continuo           Ofrece opciones de sondeo de TCP e ICMP           Crea un archivo histórico txt           Admite IPv4 y IPv6      Después de aceptar la licencia, nos solicitará el correo electronico para integrar la herramienta con GNS3, incluyendo las actualizaciones de esta  Nos volverá a solicitar los términos pero esta vez de la herramienta Solar-PuTTY, una terminal para los dispositivos de GNS3 como VPCS.  También nos solicitará el correo para Solar-PuTTY  Después de esto la instalación de GNS3 habrá finalizado  Después nos indicará si queremos herramientas básicas de la empresa solarwinds para GNS3, estas herramientas son opcionales, no influyen en el uso de GNS3  Al iniciar GNS3, iniciaremos en el asistente de configuración de GNS3, donde le indicaremos que utilizaremos GNS3 VM  Después indicaremos la ruta donde se encontrar el ejecutable del servidor, el host donde se almacenará y el puerto y protocolo de este  Nos indicará que la conexión es exitosa y podremos utilizar GNS3  Escenario  Crearemos un nuevo proyecto en el cual montaremos un pequeño escenario de 2 VPCS conectados a un switch  Finalmente, encendemos los VPCs, les asignaremos IPs diferentes y comprobaremos que tiene conexión, para ello seguiremos los siguientes pasos:          Click derecho &gt; start            Click derecho &gt; Console           ip IP_VPC MÁSCARA           ping IP_Destino      Como podemos ver ambos VPCs tienen conexión entre sí  Instalación GNS3 VM   Para la instalación de GNS3 VM debemos de dirigirnos a la web oficial de GNS3 y descargar la versión de GNS3 con el visualizador que vayamos a utilizar, en mi caso utilizaré virtualbox  Al finalizar la descarga nos dejará un archivo .zip que debemos de descomprimir  Al descomprimirlo nos dejará un archivo .ova este archivo es una máquina virtual que necesitaremos importar en virtual box  Al importar la máquina está contará con las siguientes características por defecto  Después de ésto procederá con la importación de la maquina  Finalmente ya tendremos la máquina GNS3 VM lista para funcionar  En caso de necesitar modificar en GNS3 para indicarle que vas a utilizar GNS3 VM dirígete al apartado de soluciones de errores [INDICAR A GNS3 EL USO DE GNS3 VM]  INSTALACIÓN WIRESHARK WINDOWS  Para la instalación de Wireshark en Windows debemos de dirigirnos a la web oficial de wireshark y descargar la versión necesaria para nuestro equipo, nos descargará un .exe  Una vez descargado, debemos de ejecutar el archivo .exe que nos hemos descargado.  Al instalar primero GNS3 ya nos instalará por defecto Wireshark ya que este es necesario para una funcionalidad de GNS3.  Los pasos de instalación de este son instalar WinPcap y Nmap, que se encuentran en el apartado de [INSTALACIÓN GNS3 EN WINDOWS]  CAPTURA TRÁFICO DNS  Vamos a capturar el tráfico DNS de una red wifi con un filtro de visualización, estos filtros se aplican después de haber realizado una captura general de paquetes. Comenzaremos abriendo Wireshark y realizaremos ping youtube.com  Al iniciar wireshark vemos que la interfaz de Wi-Fi ya detecta paquetes transitando, pulsaremos sobre esta para comenzar la captura.  Vemos que ha capturados varios paquetes pero vamos a filtrarlos para obtener únicamente los paquetes con el protocolo DNS  Para ello en la parte superior podemos introducir un filtro de visualización donde indicaremos por el protocolo que queremos visionar, en este caso DNS  La captura se reduce a 2 simples paquetes de 30 que teníamos.          El primero ese una consulta sobre la IP a youtube.com (standard query)           El segundo que la respuesta a la consulta que obtiene el cliente donde se indica la ip asociada a ese nombre (standard query response)      CAPTURA TRÁFICO DHCP  Iniciamos una captura de wireshark de igual modo y esta vez en el filtro de visualización introducimos el protocolo dhcp.  Muestra la comunicación entre el cliente y la maquina con el servidor DHCP, en esta comunicación podemos ver           Discover: El cliente ha enviado peticiones para encontrar un servidor DHCP           Offer: Hay un servidor por lo que ha enviado este paquete con información de la configuración que obtendrá el cliente           Request: El cliente acepta y solicita la configuración al servidor           Ack:  El servidor envía los datos y configuraciones necesarias al cliente      SOLUCIÓN DE ERRORES  DEBIAN  Dynamips  En caso de querer colocar un switch necesitamos instalar el paquete Dynamips.  Es un software de emulación de algunos dispositivos básicos como switches y principalmente utilizado para la emulación de dispositivos CISCO con sus funcionalidades.  Para instalar Dynamips, primero debemos de actualizar en caso de ser necesario con   sudo apt update  sudo apt upgrade  Después debemos de instalar snap que es un gestor de paquetes originario de la distribución de ubuntu, que facilitará la instalación de dynamips.  Este gestor reúne el paquete principal con todas sus dependencias en un paquete denominado paquete snap,  sudo apt install snapd  sudo snap install snapd     snapd: Servicio en segundo plano que administra los paquetes snap que tenemos en la maquina   sudo snap install dynamips  Reiniciamos el servicio de snapd con   sudo systemctl enable –now snapd.socket  sudo systemctl restart snapd.socket  Y ejecutar el binario de dynamips  cd /snap/dynamips/current/bin  ./dynamips  Si ejecutamos gns3 y nos dirigimos a editar &gt; preferencias &gt; Dynamips podemos ver que la ruta es la correcta en caso contrario debemos de añadirla nosotros manualmente  Finalmente ya podemos colocar switches y otros dispositivos de los mencionados anteriormente  Start VPCS  Los VPCS son ordenadores que necesitan ser iniciado, para ellos una opción es pulsar click derecho&gt;start pero si es la primera vez surge el siguiente error  Este error indica que no encuentra la ruta del binario para ejecutar los VPCS para solucionarlo, nos dirigimos a editar &gt; preferencias &gt; VPCS he introducimos la ruta del binario de los VPCS  En caso de no tener el binario de los vpcs debemos de clonar un repositorio de github  https://github.com/GNS3/vpcs/   Una vez clonado nos dirigimos al directorio vpcs/src y ejecutamos el archivo llamado mk.sh  . mk.sh  Al compilar el código obtendremos el binario de los vpcs  Finalmente volvemos al primer paso y añadimos la ruta de este binario en editar &gt; preferencias &gt; VPCS   Ubridge  Este error nos puede salir a la hora de ejecutar un VPC u otro nodo  Para solucionarlo debemos de clonar el siguiente repositorio  https://github.com/GNS3/ubridge   Nos dirigimos al directorio clonado y realizamos lo siguiente para compilar el codigo de ubridge  make  NOTA:__La compilación de estos archivos también necesita de archivos de otras dependencia como puede ser el archivo pcap.h perteneciente a la librería libpcap-dev, en caso de surgir este error a la hora de intentar compilar debemos de instalar la librería con apt install libpcap-dev o apt-get install libpcap-dev  Finalmente ejecutamos sudo make install lo que asignará permisos de ejecución al archivo de ubridge compilado anteriormente y este será copiado al directorio /usr/local/bin  En la siguiente ejecución de gns3 nos preguntará si deseamos que ubrige esté habilitado en todos los usuario  Nos solicitará confirmar en caso de pulsar yes  Finalmente ya podremos iniciar los nodos    Xterm  Para interactuar con los VPCS necesitamos de una consola, en este caso xterm  Para solucionarlo debemos de instalar la xterm  apt install xterm  Finalmente ya podemos ejecutar las consolas de los VPCS  Virbr0  Si queremos colocar una nube NAT para poder utilizar internet en nuestro escenario nos indicará que falta la interfaz virbr0 e instalemos libvirt  Debemos de instalar los paquetes apt install bridge-utils libvirt-clients libvirt-daemon libvirt-daemon-system libvirt0 libvirt-dev estos paquetes son los necesarios para solucionar este error, pero varios ya han sido instalados en pasos anteriores como al instalar gns3-gui o gns3-server como alguna dependencia          bridge-utils: Paquete que contiene herramientas de ayuda para administrar el dispositivo puente que creemos para sincronizar el escenario con la tarjeta de red           libvirt-clients: Herramientas de líneas de comandos para interactuar con libvirtd, tambien dependencia de libvirt-daemon-system           libvirt-daemon: Dependencia del paquete libvirt-daemon-system           libvirt-daemon-system: Ofrece un demonio (libvirtd) y un conjunto de sistemas para gestionar diferentes sistemas de virtualización             libvirt0: Dependencia de libvirt-dev           libvirt-dev: Contiene archivos de desarrollo para la librería libvirt      Comprobamos el servicio de libvirtd sudo systemctl status libvirtd  Miraremos el estado de la red virtual con la herramienta virsh, está herramienta permite administrar las redes, almacenamiento… de visualizadores como KVM, se instala como una dependencia de los paquetes anteriores   sudo virsh net-list –all  Debemos de modificar el estado e inicio automático, estos deben de estar activos, para ello utilizamos  sudo virsh net-start default  sudo virsh net-autostart default   Finalmente reiniciamos los servicios de libvirtd y comprobamos los cambios de ajustes virsh y que se ha creado el puente virtbr0  Con el comando ip link o ip a veremos la creación de la interfaz virbr0  Podemos colocar la nube y navegar por internet  Previamente le he indicado al PC2 que obtenga una IP del servidor DHCP con el comando ip dhcp y con ping 8.8.8.8 he comprobado la conexión con los servidores de google  Captura de tráfico wireshark  Si queremos capturar el tráfico en algún escenario nos puede surgir el siguiente error  Para solucionar este error debemos de asignar permisos de ejecución al binario de dumpcap  sudo chmod +x /usr/bin/dumcap   Ya no surgirá el error al volver a intentar capturar el tráfico ya   Instalación VirtualBox  Primero debemos de descargar el paquete .deb oficial de VirtualBox, podemos descargarlo desde la web oficial o desde la linea de comandos con wget   https://download.virtualbox.org/virtualbox/7.1.4/virtualbox-7.1_7.1.4-165100~Debian~bookworm_amd64.deb   A continuación instalaremos el paquete .deb con el comando dpkg -i nombre_paquete.deb     dpkg -i: dpkg es un gestor de paquetes, con los parámetros le indicamos a este gestor que debe de hacer con los paquetes, en este caso -i lo instala    Después de esto ya tendremos listo VirtualBox para su uso lo que faltaría únicamente sería importar la maquina de GNS3 VM   WINDOWS  No se encuentra la máquina GNS3 VM   Nos puede surgir un problema a la hora de iniciar GNS3 en windows debido a que le indicamos durante la instalación que vamos a utilizar GNS3 VM pero esta no está importada todavía  La solución a este problema es realizar la [instalación de la máquina GNS3 VM]  Indicar a GNS3 el uso de GNS3 VM  Para indicarle a GNS3 que vamos a usar GNS3 VM debemos ejecutarlo y dirigirnos a la opción de Help &gt; Setup Wizard  Aquí debemos de indicarle la primera opción de ejecutar las imagenes de los dispositivos en la máquina virtual de GNS3VM  Después de esto los siguientes pasos serán similares a como se ejecutó GNS3 por primera vez, hasta el último apartado  En el último apartado nos surgirá un error debido a que GNS3 VM por defecto cuenta con que la máquina será con el visualizador de VMware, cosa que en este caso está con Virtualbox.  Para ello es tan simple como marcar la opción de Virtualbox y pulsar en next  Finalmente tenemos un resumen de las características de GNS3 VM y listo para su uso  BIBLIOGRAFÍA  https://superuser.com/questions/1788720/how-to-install-gns3-on-debian12  https://github.com/GNS3/dynamips/blob/master/README.md  https://www.gns3.com/community/featured/could-not-find-dynamips-2  https://github.com/GNS3/ubridge  https://gns3.com/community/featured/error-while-setting-up-node-virb  https://www.josedomingo.org/pledin/2013/11/gns3-anadiendo-hosts-a-nuestras-topologias/  https://doc.qt.io/qtforpython-5/PySide2/QtWebSockets/QWebSocket.html#more  https://www.geeksforgeeks.org/python-introduction-to-pyqt5/  https://blogubuntu.com/que-es-ubuntu-snap  https://askubuntu.com/questions/1317937/difference-between-snap-and-snapd  https://dggonzalez5549.wordpress.com/2017/12/12/wireshark-solucion-al-problema-couldnt-run-usr-bin-dumpcap-in-child-process-permiso-denegado-en-ubuntu-17-10-y-derivados/  https://www.winpcap.org/  https://docs.gns3.com/docs/getting-started/setup-wizard-gns3-vm/  https://achirou.com/guia-rapida-de-wireshark-todos-los-comandos-filtros-y-sintaxis/#Filtrado_de_paquetes_filtros_de_visualizacion  https://www.redeszone.net/tutoriales/internet/que-es-protocolo-dhcp/  https://fp.josedomingo.org/hlc2122/u01/introduccion.html  https://www.debian.org/distrib/packages"
  },
  
  {
    "title": "Redes Apuntes",
    "url": "/posts/REDES-APUNTES/",
    "categories": "",
    "tags": "",
    "date": "2025-10-20 00:00:00 +0200",
    "content": "ÍNDICE  Definiciones\t3 TEMA 1 REDES LOCALES\t3 1.0 RED LOCAL\t3 VENTAJAS\t3 1.1 CARACTERÍSTICAS CPDS Y SERVIDORES\t5 SERVIDOR\t5 CLOUD\t5 2.0 ELEMENTOS RED LOCAL\t5 3.0 CLASIFICACIONES DE REDES Y CRITERIOS\t7 SEGÚN SU TAMAÑO O EXTENSIÓN\t7 SEGÚN LOS MEDIOS DE TRANSMISIÓN\t8 GUIADOS\t8 NO GUIADOS\t9 SEGÚN LA TOPOLOGÍAS DE RED\t9 SEGÚN LA TECNOLOGÍA DE TRANSMISIÓN\t10 SEGÚN EL MODO DE TRANSMISIÓN\t10 4.0 TIPOS DE SERVIDORES\t10 TEMA 2 PROTOCOLO TCP/IP\t12 EJERCICIOS\t14 ESTÁTICAS/DINÁMICAS\t15 RESERVAR/EXCLUIR IPS DHCP\t16 RANGO DIRECCIONES PRIVADAS\t16 EJERCICIOS\t17 ENRUTAMIENTO\t18 INTRODUCCIÓN AL PROTOCOLO TCP/IP\t20 PROTOCOLO DHCP\t22 PROTOCOLO ARP\t23 PROTOCOLO DNS\t23 DNAT\t24 SNAT\t24 COMO FUNCIONA TCP/IP EN LA REALIDAD\t25 ICMP\t28 TEMA 3 NIVELES FÍSICO Y ENLACE\t29 NIVELES FÍSICOS\t29 HERRAMIENTAS\t29 DEFINICIONES\t29 EJERCICIO\t30 FIBRA ÓPTICA\t31 EJERCICIO\t31 VELOCIDADES MEDIOS\t32 NIVEL ENLACES\t32 CARACTERÍSTICAS AL COMPRAR SWITCH\t35 REDES VIRTUAL (VLANS)\t37 VLANS\t37 ESPECIFICACIONES DE CISCO\t38 NAT\t38 SNAT\t38 DNAT\t39 SNAT CISCO\t39 CORTAFUEGOS\t39 NODO\t40 PERIMETRAL\t40 MODULOS IPTABLES\t41 COMANDOS\t42 ENCAMINAMIENTO DINÁMICO\t42 PROTOCOLOS DE VECTOR DE DISTANCIA\t42 PROTOCOLO DE ESTADO DE ENLACE\t43 VPN (VIRTUAL PRIVATE NETWORK)\t43  Definiciones  Help Desk: Técnicos encargados de la resolución de problemas, hay varios niveles [1-3], y estos son escalables en función del problema. Servidores: Máquinas con gran hardware, estas normalmente no tienen teclado ratón ni pantalla ya que a estas se accede a través de red normalmente por ssh, normalmente solo acceden a ellas los administradores INTRANET: Conjunto de hardware y software que tiene la empresa para los trabajadores de esta, la información se tiene en un servidor de datos y se accede a través de un servidor web, es una manera de organizar el trabajo de una empresa, a través de la web directamente realiza todo lo que necesite: EJ: SÉNECA; Siempre te tienes que identificar para acceder a esta EXTRANET: Obsoletas ya que todas las intranet permiten ya el acceso remoto DNS SOBRE HTTPS(DOH):  Protocolo: Conjunto de normas  RFC: Request for comments TORMENTA DE BROADCAST: Principalmente creadas por un bucle en algun switch de la rede local lo que genera un colapso de la red por completo  TTL: Tiempo de vida de los paquetes, cada vez que salta se reduce a uno evitando para evitar paquetes perdido sin la red  TEMA 1 REDES LOCALES 1.0 RED LOCAL Una red local es el conjunto de ordenadores y/o dispositivos (nodos) conectados entré sí que comparten información recursos o servicios, para que esto ocurra se necesita transmision VENTAJAS  Compartir recursos: Esto reduce el número de periféricos evitando comprar uno por cada equipo (Consecuencia: Más espacio y menos gastos) Compartir información: Los dispositivos pueden compartir información, a través de carpetas compartidas, servidores de datos o servidor web si se utiliza una Intranet Fiabilidad: Se mejora la fiabilidad pudiendo realizar copias de seguridad almacenadas en un servidor de datos, redundancia de los servidores más importantes y las actualizaciones se podrán hacer desde la red evitando hacerlas manualmente Rendimiento: Se puede mejorar el rendimiento montando y utilizando clusters de ordenadores Alta disponibilidad: Conjunto de ordenadores con redundancia entre si o de un servicio específico Alto rendimiento: Conjunto de ordenadores haciendo tareas cooperativas para obtener mayor rendimiento. Antes del cluster suele haber un balanceo de carga para dividir las peticiones, procesos…  Medio de comunicación: Al montar la red, los miembros de esta pueden estar comunicados entre sí, a demás está comunicación se puede regular por ejemplo en distintos departamentos u otorgar más privilegios a algunos usuario que otros  1.1 CARACTERÍSTICAS CPDS Y SERVIDORES  Mantener estable la temperatura y buscar una temperatura fría sin que se condense la humedad para evitar mojar los servidores. En función del precio de la luz se pone a una temperatura u otra dependiendo si sale más rentable o no (antes 16ºC/17ºC ahora 20ºC/23ºC)  Los servidores se almacenan en armarios en forma de rack normalmente estos armarios tienen medidas estándares y se mide por unidades de armarios (rack) por ejemplo 42U.  SERVIDOR En comparación con un cliente, más CPU, RAM, Discos más rápidos, mayor calidad, Redundancia(Métodos para seguir con el funcionamiento de este), 95% linux CLOUD Escalabilidad de recursos y pago por lo que uso  2.0 ELEMENTOS RED LOCAL  SERVIDOR: Equipo o dispositivo que provee de uno o varios servicio  CLIENTES: Equipo o dispositivo que solicita servicios al servidor  Suelo técnico: Un suelo que se pone por encima del suelo verdadero para ocultar los cables Ventajas: No hay que tirar canaletas, si hay cambios en la oficina no hay problemas a diferencia de las canaletas que si estorban  Desventajas: Caros  OTROS DISPOSITIVOS: Además de servidores y clientes se pueden encontrar impresoras Plotter…  TARJETAS DE RED: Permite la conexión de dos ordenadores entre sí, puede estar integrada en la Placa Base, en un slot de expansión o a un puerto USB… (Conector hembra)  CABLES Y CONECTORES Cables RJ45: Ambos extremos conectores machos, encargados de la conexión de una tarjeta de red con otra u otro elemento de la red  PATCH PANNEL: Conjunto de conectores hembras (4,8,16,24) al que se conectan los cables de red de las canaletas y de ahí otros cables hacia el switch  cable pc-roseta: Latiguillo  cable roseta-patch pannel: Canal permanente  cable patch panel-switch: Latiguillo de armario  Canaletas, torres y paneles:  Las canaletas son estructuras las cuales protegen y cubren los latiguillos, hay de suelo y techo Torres de suelo: Puntos de corrientes Paneles: Puntos de corrientes  Hub: Precursores de los switch y tontos, son pura electrónica, toda señal que le llega por una boca la reenviar por el resto, cosa que no sucede con el switch. No tenía seguridad a la hora de transmitir los datos  Switch: Dispositivo que sirve para crear una red local, lo que permite la conexión de diferentes dispositivos, similar al hub, pero reenvía los datos según una dirección MAC especificada en los datos a transmitir  Router: Dispositivo que conecta dos o más redes distintas  Router doméstico: Actúan como un pequeño switch punto de acceso e interconectan las redes del proveedor de internet y la red local  REGLA PARA LAS CANALETAS: SOLO SE PUEDEN USAR ⅔  DEL ÁREA DE LA CANALETA EJ: CANALETA CON ÁREA DE 1000 CM 2 SOLO SE PUEDE UTILIZAR 666 CM 2 ESO DIVIDIRLO ENTRE EL ÁREA DEL CABLE (60 CM 2) 660/60 = 11 CABLES POR CANALETAS  AP/WAP: Dispositivo similar al hub pero el medio de transmisión de datos es el aire, estos dispositivos normalmente van conectados a otro dispositivo como un switch o un router, en otros casos se conectan directamente con la línea telefónica, a este tipo se le conoce como router inalámbrico  Las redes inalámbricas son como las redes conectadas por hubs, el medio del aire es el mismo para todos por lo que los paquetes chocan de no ser porque hay métodos para controlar la emisión de paquetes y hay métodos de encriptación para garantizar la integridad de los datos que transmite los dispositivos (WPA2/3)  Armarios: Pueden tener varias entradas además de la puerta, entradas superior e inferior y paneles laterales desplegables. Hay armarios con una bisagra que permiten extraer todo el contenido para poder abrirlo y reparar en cualquier momento de forma muy cómoda  CUADRO ELÉCTRICO INTERRUPTORES DIFERENCIALES: Protegen a las personas, si la electricidad se está fugando por algún lado, corta la serie de circuitos necesarios INTERRUPTORES MAGNETO TÉCNICO: Protegen la propia instalación: Genera un circuito y a ese circuito se conectan dispositivos eléctricos. Hay varios interruptores magnetotérmicos, para diferentes circuitos de diferentes amperajes  10A—------1,5mm2 alumbrado 16A—------2,5mm2 fuerza 20A—-------Frigorifico lavavajillas 25A—-------Horno   10A*220V==2200W  por cada 3 magnetotérmicos 1 diferencial en instalaciones de red cables negativo positivo y masa conectores mesas electrificadas  PLANIFICAR REDES  Saber material a utilizar y calcular los costos Saber plasmar gráficamente la estructura de la red (planos) Saber las tareas que se van a necesitar, personal necesario para llevar a cabo las tareas, el orden para hacerlas y saber cuales se pueden hacer a la vez y cuales no  armariorack.es  3.0 CLASIFICACIONES DE REDES Y CRITERIOS SEGÚN SU TAMAÑO O EXTENSIÓN  PAN: Personal area network, en estás redes normalmente el método de comunicación es bluetooth.(Mobile-wearables) Acceso muy sencillo Radio de alcance muy limitado Inalámbrica Costes de instalación bajos o nulos.  LAN: Local area network, el tamaño de estás son de edificios, oficinas o casa. En ámbito doméstico lo normal es inalámbrica, suele ir a un tercio de la red cableada y esa velocidad dividirla entre los dispositivos conectados a esta en ámbito profesional cableada. Velocidad de transmisión de 1Gbps Toda la red pertenece a una misma organización (privada) Tamaño de edificio oficina o casa   MAN: Metropolitan area network, cubren una ciudad pueblo o una ciudad y los pueblos de alrededores Suelen trabajar con fibra óptica Suelen ofrecer servicios integrados como datos, voz y video  WAN: Wide area network, redes que cubren países o continentes  SEGÚN LOS MEDIOS DE TRANSMISIÓN GUIADOS  Es el medio por el que viajan los datos, medios guiados(cables) o medios no guiados (inalámbricas) o mixtas Hay varios tipos de cables para los medios guiados  Par paralelo: Dos hilos de cobre paralelos con una funda de plástico, es muy vulnerable a las interferencias Par trenzado: Contiene 8 cables en 4 parejas de 2, al estar trenzado es mucho más resistente a las interferencias electromagnéticas Fibra óptica: Contienen un hilo de un porómetro para que circule y rebote la luz. Alcance mucho más ampliado, depende de la calidad  Coaxial: Se utilizan para los enlaces exteriores desde el punto de acceso hasta las antenas, compuesto de una parte interna después funda de plástico,maya de cobre y otra funda de plástico. Cuesta mucho conectorizar un cable coaxial  NO GUIADOS Utilizan el aire como transmisor dependen mucho de la frecuencia si distancia aumenta y la facilidad de atravesar obstáculos Ondas de radio: Microondas: Infrarrojos: Poco alcance y necesita visión directa Ondas de luz: Antiguo método, Lifi: Utilizando los leds, se envía información, similar a los infrarrojos se necesita visión directa   SEGÚN LA TOPOLOGÍAS DE RED  Se refiere a la estructura de los dispositivos de la red  Topología en bus: Contaba con un único cable al que se iban conectando los ordenadores, no había un nodo central de la red. Compuesto por un cable coaxial y en los extremos 2 terminadores para evitar que la señal rematará. Red muy barata, desventaja al haber una avería la red entera se caía. Para averiguar la avería se quitaba el terminador del final y se iba poniendo en diferentes alturas para averiguar dónde estaba el fallo. El ancho de banda se dividía por el número de máquinas.  Redes en anillo: Se utilizan para redes con gran volumen de tráfico, tiene el mismo error que las redes en bus a la hora de sufrir una avería y se suele utilizar 2 anillos, para evitar los problemas y tener una a modo de soporte (redundancia), se suelen poner por diferentes lugares un anillo de otro, cada nodo que se conecta a este actúa de repetidor, se suele utilizar en redes MAN  Redes en estrella: Utilizan un nodo central normalmente un switch o un conjunto de estos. Normalmente cuando dos elementos de la red se quieren conectar el switch hace de intermediario, el tráfico siempre pasa por el. Cuando se estropea una parte de la red solo se estropea esa parte y el resto de la red sigue funcionando y el ancho de banda no se comparte siempre que las comunicaciones entres los nodos sean diferentes entre sí (PC1-PC2  PC3-PC4), la desventaja el la cantidad de cable que se necesita  Redes mixtas: En la realidad las redes se forman juntando las topologías anteriores por ejemplo estrella-estrella anillo-estrella anillo-estrella-estrella  VPN: lÍNEA DE TRÁFICO CIFRADO PERO SE UTILIZA LAS LÍNEAS DE INTERNET, ESTA LÍNEA VIAJA POR INTERNET ENCRIPTADAS  BEST EFFORT: Mejor esfuerzo SEGÚN LA TECNOLOGÍA DE TRANSMISIÓN  Punto a punto: La comunicación se hace solo entre 2 nodos. Se puede dar de dos maneras Conmutación de circuitos: Primero se establece la conexión antes de la conexión, en los repetidores por los que se va a realizar la conexión se debe de reservar un slot(hueco en los repetidores), si no hay slots libres no se puede realizar la comunicación . Cuando se finaliza la comunicación se liberan los slots Conmutación de paquetes: Se divide la información y se envía por un camino que no tiene porque ser el mismo siempre  Difusión: Los mensajes interesa que lleguen a todo el mundo, no tiene ningún receptor específico.  SEGÚN EL MODO DE TRANSMISIÓN  Simplex: La comunicación es unidireccional, El transmisor es capaz de transmitir pero no recibir o el receptor es capaz de recibir pero no de responder  Semi-dúplex: Puede ser bidireccional pero no simultánea, se puede recibir y escuchar pero no a la vez EJ: Walkie Talkie o tarjetas de red  Full-duplex: Transmitir y recibir simultáneamente  4.0 TIPOS DE SERVIDORES  Los de BASE DE DATOS: Almacena la información de forma relevante sobre la empresa guardando esta en forma de tablas, esta información se consulta con aplicaciones o programas de la empresa. Compuesto de discos duros con mucha capacidad. Un cliente utiliza la aplicación o navegador que lleva a una página web (servidor web), en función de lo que solicite en la web, este servidor web se conecta al servidor de base de datos y este ya devuelve la información de las tablas   LOS SERVIDORES WEB: Un cliente realiza peticiones a través de navegadores web en un lenguaje http o https. Para que un ordenador funcione como un servidor se necesita un software específico para que este ofrezca servicios y ser un servidor, en caso de un servidor de base de datos utilizo oracle en uno web apache. Estos software permiten al servidor entender el lenguaje con el que se realiza la petición de las otras máquinas. Estas máquinas son las que guardan las páginas webs de las empresas  PROPIO: Libertad total sobre el servidor desventaja   SERVIDOR PROXY: Su función es compartir la conexión a internet con otras páginas. Es importante ya que permite cachear las páginas, es decir almacenar las webs que se solicitan. Cuando se realiza una consulta a una web, el proxy almacena temporalmente una copia de esta para cuando se vuelva a solicitar no navegar por internet. Las paginas con https con login no se cachean. Con el incremento del https esta parte del proxy está siendo obsoleta. Cuenta con 2 funciones más importantes  Centralizar la navegación: Es importante para monitorizar el tráfico de la red, los proveedores de internet registran los tráficos de los clientes, en caso de utilizar VPN se sabrá que se ha utilizado una vpn pero no donde ni que se transmite por esta.   Filtrado de tráfico: Se puede configurar como una especie de firewall de lista negra o blanca para limitar la navegación incluso bloquear búsquedas de palabras concretas o webs que contenga en su url palabras concretas  SERVIDOR APT-PROXY: Caché paquetes de linux, si se tiene montado, en vez de guardar copias de las webs guarda los paquetes  SERVIDOR PROXY-INVERSO: Si en una red hay varios servidores webs guarda la lista de los servidores que devuelve  SERVIDORES DE MÁQUINAS VIRTUALES: Los clientes a través de una interfaz gráfica se accede al servidor de las máquinas virtuales, esta interfaz suele ser alojada en un servidor web que en estos casos se suelen alojar en la misma máquina que actúa de servidor de máquinas virtuales   TEMA 2 PROTOCOLO TCP/IP  BINARIOS  2⁷\t2⁶\t2⁵\t2⁴\t2³\t2²\t2¹\t2⁰ 0\t1\t0\t1\t1\t1\t1\t0  0\t64  Hexadecimal base de numeración de base 16 (16 dígitos posibles), son: 1-9 A,B,C,D,E,F   A=10 B=11 C=12 D=13 E=14 F=15  El numero más grande con 2 digitos en hexadecimal es FF  FF F¹\t+ F⁰  1515\t+151  PARA PASAR DE BINARIO A HEXADECIMAL 0\t1\t0\t1\t1\t1\t1\t0 ——————————-\t——————————– \t5\t\t\t\tE  5*16¹ +E  EL NÚMERO 123  2⁷ 2⁶ 2⁵ 2⁴ 2³ 2² 2¹ 2⁰ 128 64 32 16 8 4 2 1 1 0 1 0 0 1 0 0  DEC-BIN\t\tBIN-DEC 123\t\t\t00110011 18\t\t\t10101000 200\t\t\t11101110 220\t\t\t01011110 115\t\t\t10111110  01111011\t\t51 00010010\t\t168 11001000\t\t238 11011100\t\t94 01110011\t\t190  Comando ip a devuelve información de la tarjeta de red, en esta información podemos ver  El estado: State UP/DOWN Dirección de enlace (link) y el tipo (ether): 4c:cc:6a:e5:ec:ce esta es la direccion MAC, cuenta con 48 bits en bloques de 8 bits  4c: este es un bloque de 8bits  Los primeros 24 bits indican el fabricante y modelo  inet(direccion a nivel de red): Es la dirección ip y se usa en el nivel de red, escrita en decimal separadas por punto con 4 numeros 112.22.34.1 llamada notación decimal puntuada Cada número es un conjunto de 8 bit en siendo un total de 32 bits 1011010101010101010101010101010  El uso de binarios se utiliza en las direcciones IP  ENLACE: Dirección MAC de 48bits 00:00:74:32:A7:B1 RED: Dirección de IP (32 bits, representada en notación decimal puntuada) + Máscara de red (32 bits)  En una dirección IP hay 2 partes, una parte que se refiere a la red en la que estoy y otra parte al host concreto de esta red.  Es importante saber que parte es necesaria para la red y otra para el host ya que si hay varios host en la misma red, se pueden comunicar sin un ruter.   Para saber que parte pertenece a la red dentro de una ip se utiliza una mascara de red, la máscara de red indica la cantidad de bits que se utilizan EJ: 192.168.x.x = 1111111.1111111.00000000.00000000 Los bits a 1 son los utilizados por la red los 0 al host  Se utilizan 2 notacions, la decimal puntuada 255.255.255.255 o /32  192.168.0.1 /16: Utiliza los primeros 16 para la red, el resto host 192.168.0.1 255.255.0.0: Utiliza los primeros 16 para la red, el resto host  EJERCICIOS Di si estas parejas de ordenadores están en la misma red  192.168.1.1 /16  192.168.0.1 /16 \tSI  192.168.1.1 /24  192.168.0.1 /24\tNO  80.59.1.152 /28  80.59.1.201 /28\tLos bits del 25 al 28 son diferentes por lo que NO estan en la misma red  01010000.00111011.00000001.10011000 01010000.00111011.00000001.11001001   12.11.13.14 /12  12.14.12.13 /12\tLos 12 primeros bits SI coinciden  12.00001011.13.14 12.00001110.12.13  120.140.160.180 /18  120.140.180.200 /18\t\tSI  120.140.10100000.180 120.140.10110100.200  200.200.200.200 /5  160.0.0.0\t/5\t\tNO, a demás la segunda IP es la dirección de una red  11001000 10100000  ESTÁTICAS/DINÁMICAS Dos ordenadores no pueden tener una misma IP en la red, porque no se identifican, en una red pequeña se pueden poner las IP estáticas pero en redes grandes no es factible por lo que se configura la máquina para que estas tengan ip dinámica  Puerta de enlace: Nodo de mi red, al que voy a enviar los mensajes con destino fuera de la red local (router, máquinas cortafuegos y configuradas como router, proxy …)  Estáticas: Se configuran a mano. Dinámicas: Aplica el modelo cliente servidor, las máquinas clientes solicitan una configuración IP al servidor DHCP dentro de está configuración se encuentra la IP a utilizar (IP, máscara de red, puerta de enlace, servidor DNS …)  Cuando se configura un servidor DHCP se puede configurar para reservar una IP para nodos específicos evitando así que siempre cambie, esto puede aplicarse a servidores o nodos como routers si estos cambian la IP los clientes no saben encontrarlos para ello en la configuración DHCP se puede reservar para esos dispositivos   RESERVAR/EXCLUIR IPS DHCP Se puede configurar un rango de direcciones IPs 172.22.0.0 /16 exlused.address 172.22.0.1 - 172.22.0.6  Tambien se pueden por reservas   Reserves  MAC IP Mac_servidor Ip_para_maquina_con_esa_mac A1:B1:B1:A1:C2:C3 172.22.0.3/16  default-lease-time 86400; Esta configuración indica el tiempo válido de asignación de la ip de la máquina  fixed-address 192.168.1.3: Esto es para una reserva  ISP: Proveedores de servicio de internet  Un router doméstico de nuestra casa tiene 2 caras una red local que actúa de DHCP para los dispositivos de nuestra casa y otra cara en la que actúa de cliente y solicita la configuración IP del servidor DHCP el cual es un router o máquina de nuestro ISP  Las IPV6 están compuesta por 128 bits, fue una solución ante la futura falta de IPV4 en el mundo, la implantación de IPV6 es muy lenta a hoy dia no está implementado al completo, después de eso crearon las IPs públicas e IPs privadas  IPs públicas: Estas IPsV4 si son únicas en el mundo  IPs privadas: Con estas IPsV4 no son únicas se repiten en millones de redes pero si es única en una red local, con estás IPs no se puede navegar por internet.  Para navegar por internet se utiliza la IP pública asignada al router que es asignada por el ISP, en las redes locales cuando algún equipo necesita navegar, se realiza un proceso llamado NAT por el cuál se utiliza la IP publica del router en vez de las privadas de las máquinas RANGO DIRECCIONES PRIVADAS  10.X.X.X 172.16.X.X-172.31.X.X 192.168.0.X-192.168.255.X   NAT: Normalmente se configura en los router, proceso por el que se traduce las IPs de públicas a privadas, también se puede configurar en otros dispositivos  Mascara de red: Numero de 32 bits que me dice que parte es dirección de red y que parte es el numero de host dentro de esa red  Hay una dirección que es la primera es decir en en una /24 la ip 192.168.0.0 es la primera y representa a toda la red, no se puede asignar a ninguna maquina  Hay una dirección llamada dirección de difusión que es la ultima, es la dirección para enviar un mensaje a toda la red esta representa a todos los ordenadores, con la misma red de arriba la difusión seria 192.168.0.255  EJERCICIOS  Tengo un ordenador con la IP 130.120.240.12 y máscara de red /20  Indica: La máscara de red en notación decimal puntuada La Dirección de la red. La dirección de difusión de esa red El número de ordenadores que puede tener esa reed De qué dirección a qué dirección podemos usar para identificar los ordenadores de esa red Si el ordenador con IP 130.120.250.2 pertenece a esa red  a)255.255.240 .0 b)Es la primera dirección de esa red, es decir aquella que tiene todos los bits de host a 0  130.120.240.12 100000010.01111000.11110000.00001100 100000010.01111000.11110000.00000000 130.120.240.0  c)130.120.240.12 100000010.01111000.11110000.00001100 100000010.01111000.11111111.11111111 130.120.255.255  d) Necesitamos saber cuantos bits tenemos para enumerar los ordenadores  Cuento los bits de host y realizamos la siguiente operación  2^n host - 2 2¹² - 2 = 4096 -2 = 4094 ordenadores  C) Necesito utiliza la primera que es posible asignar a los equipos por lo que la .0 no es validad y lo mismo con la de broadcas .255 no vale  130.120.240.1 hasta 130.120.255.254  f) Comprarlo los primeros bits 20 bits o miro si está entre el rango de las IPs validad  ENRUTAMIENTO En un router cuando llega un mensaje se mira el destino de este y se empieza a leer la tabla de enrutamiento de este para saber por dónde enviarlo  Si quiero llegar a algun servidor, no se sabe cómo llegar al servidor sino que se sabe utilizando el gateway iré saltando de router en router hasta llegar a mi destino, estos routers no saben el camino completo pero saben cual es la mejor opción posible para llegar al destino, estas mejores opciones se basan la cantidad de saltos de router en router, ver la cantidad de tráfico si está muy saturado se descarta, que esté operativo o la cuota que impone el ISP.  En internet hay miles de routers pero normalmente para llegar al destino lo normal es dar entre 8-15 saltos a otros router, si un paquete llega a dar 65 saltos este se elimina ya que se considera perdido.  Una tabla de enrutamiento va a contar con las siguientes columna  DESTINO \tSIG_ROUTER\t\tINTERFAZ_SALIDA\tCOSTE IP_DESTINO   IP_sig_router + interf\tmi_interfaz_salida  En redes locales se utiliza enrutamiento estático donde se rellenan las tablas manualmente y en internet se utiliza el enrutamiento dinámico que utilizan un algoritmo (OSPF,RIP…) estos algoritmos preguntan constantemente a sus vecinos cuanto tardan y a donde saben llegar con esto ya saben por donde enviar los paquetes  En las tablas de enrutamiento primero se busca las IPs de las máquinas en caso de que no exista se busca la IP de la red que tambien es valida, las tablas se leen verticalmente  Si queremos evitar las conexiones con una red o máquina específica, normalmente se utiliza cortafuegos pero con tablas de enrutamiento también se puede utilizar modificando la ip de destino por una que no existe tambien puede funcionar modificando la interfaz de salida pero a veces los routers no te deja esta opción  En la vida real debemos de optimizar las rutas, analizarlas para saber la cantidad de trafico que tienen para saber cual es la mejor ruta  En una red tenemos un ordenador configurado con la IP 192.168.1.239 CON LA MÁSCAR /29  Indica la máscara de red en notación decimal puntuada La dirección de la red en la que está dicha máquina La dirección de broadcast o difusión de la red en la que está dicha máquina El número máximos de dispositivos que porá tener esa red Como prodrá comunicarse el ordenador anterior con la máquina 192.168.1.250  255.255.255.248 192.168.1.111011111 -&gt; Ip maquina   192.168.1.111011000 192.168.1.232 192.168.1.111011111 -&gt; Ip maquina   192.168.1.111011111 -&gt; 192.168.1.239 2³-2 = 8 -2 = 6 Esta máquina no puede comunicarse ya que tiene asignada la dirección e broadcast de la red /29, además la ip X.X.X.250 estaría fuera de la red ya que supera la 239 o al ser otra red a través de un router    En una red tenemos un ordenador configurado con la IP 172.22.68.12 CON LA MÁSCAR /20  Indica la máscara de red en notación decimal puntuada La dirección de la red en la que está dicha máquina La dirección de broadcast o difusión de la red en la que está dicha máquina El número máximos de dispositivos que porá tener esa red Como prodrá comunicarse el ordenador anterior con la máquina 172.22.90.1  f) 255.255.240.0 g) 172.22.01000100.00001100 -&gt; IP maquina      172.22.01000000.0000000 -&gt; 172.22.64.0 h)172.22.01001111.11111111 -&gt; 172.22.79.255 i)2¹²-2 = 4096-2 = 4094 host disponibles j)La ip X.X.90.1 es de otra red por lo que se necesitarán conectarse a través de un router    TRUCO PARA CALCULAR LAS POTENCIAS 2¹⁰ = 1024 2²⁰ = 1048576  2¹² = 2¹⁰ * 2²  2¹⁶ = 2¹⁰ * 2⁶  2²⁹ = 2¹⁰ * 2¹⁰ * 2⁹ = 2²⁰ * 2⁹ INTRODUCCIÓN AL PROTOCOLO TCP/IP  Hay otros protocolos aparte de TCP/\tIP hace años las empresas como IBM tienen sus propios protocolos por lo que solo las maquinas de esas marcas podían comunicarse entre si y no con otras de otras marcas Se decidió crear un protocolo que no fuera propiedad de nadie, esté fue TCP/IP que durante años estuvo compitiendo con los protocolos de las empresas como IBM, MICROSOFT… hasta los 90 donde TCP/IP ya se usaba en internet. En TCP/IP divide sus normas en diferentes capas o niveles (físico, enlace,red,transporte y nivel de aplicación) Físicos: Garantiza que un PC puede transmitir y recibir información.  Normas como pueden ser el tamaño de los conectores, el orden de los cables RJ45, la potencia de señal de transmisión etc. Aspectos eléctricos y electrónicos principalmente nos centraremos en redes de cobre donde si hay voltio representan 1 si hay ausencia de voltios es 0, en redes inalámbricas se utiliza un cambio de fase de ondas y en fibra óptica es similar al cobre pero con pulsos de luz  Enlace: Dos nodos que están en la misma red local se puedan comunicar, cómo saber cuando un ordenador puede transmitir o no (control de acceso al medio), también casi todo lo relacionado con los switch, en resumen la relación de cómo funcionan las redes locales. También se encarga de la forma de acceder al medio y saber si es capaz de transmitir viendo si el medio de transmisión está libre para evitar colisiones de los paquetes  Detección de colisiones: Se usa en redes de cobre e inalámbricas. Los nodos que quieren transmitir se ponen en escucha para saber si el canal está ocupado, en caso de estar ocupado se espera X tiempo si no empieza a transmitir. Hay un periodo de tiempo en el que un equipo empieza a transmitir pero el equipo no le ha dado tiempo de escuchar por lo que también empieza a transmitir y se producen las colisiones. La encargada de esto es la tarjeta de red.  Paso de testigo: Se usa en redes de fibra óptica. Al ser normalmente redes en anillos con mucho tráfico la detección de colisiones no funciona muy bien por lo que se utiliza este método. Consiste en asignar X tiempo por segundo para transmitir a los equipos.  En el nivel de enlace también se divide la información en paquetes o tramas, dependiendo del tipo de medio de transmisión el tamaño de los paquetes varían.   MTU (Max Transfer Unit): Tamaño máximo de un paquete en función del medio porque sino el rendimiento de la red baja y la probabilidad de fallo aumenta, en redes inalámbricas el MTU es bajo por lo que se envían paquetes más pequeños, en fibra óptica se dividen en paquetes grandes y en cobre es un término medio. Se puede configurar el tamaño de estos  También se añaden mecanismos para saber sin un mensaje a llegado correctamente para comprobar la integridad de los datos transmitidos, utilizando un CRC (Código redundante cíclico), antiguamente se usaba el bit de paridad, si se iban a transmitir 8 bits el emisor añadía otro donde antes de comunicar se llegaba a un acuerdo el emisor y el receptor si se decidía par o impar el bit del final que se complementa para comprobar si el mensaje llega íntegro, pero esto solo funciona cuando falla 1 solo bit en la transmisión ya que si fallan 2 estos pueden camuflarse entre sí y no permite saber en qué posición ha fallado. Más adelante se complementa con 3 bits de paridad en vez de 1 teniendo que transmitir un 30% más por lo que satura mucho la red y esto solo se puede permitir en transmisiones que no pueda perder la información. Una tarjeta de red coje los 1500bytes del mensaje este mensaje se somete a una división por un polinomio y nos quedamos con el resto (circuito integrado) y se obtiene del resto un número de 32 bits que es el CRC finalmente el receptor recopila los bytes del paquete y realiza la misma operación y compara el resultado con el número de 32bits. Es decir por cada 1500 bytes se transmiten 15004 bytes.   Control de flujo: Si el buffer (pequeño espacio de almacenamientos), está lleno de la información recibida, para evitar que se pierda la información, activa el mecanismo de control de flujo, al ejecutarlo la tarjeta de red envía una señal al emisor para indicar que pare de transmitir y evitar la pérdida, después de que el buffer baje de x umbral le indica que vuelva a transmitir.  Red: Dos ordenadores de diferentes redes puedan comunicarse, en general todo lo que tiene que ver con conectar 2 redes diferentes y el dispositivo encargado de esto es el router. Las máquinas se identifican por IP y no por mac y es el encargado del que los ordenadores de diferentes red se puedan comunicar. Enrutamiento de trama: como hacer que un mensaje llegue hasta su destino aunque tenga que atravesar distintas redes. También se regula la congestión de la red, en caso de que los routers tengan enrutamiento dinámico, estos son capaces de modificar las sus tablas de enrutamiento para escoger la mejor ruta El router se encarga de reestructurar los tamaños de los paquetes de diferentes niveles de enlaces de distintas redes es decir los paquetes en una red wifi tienen X tamaño y se utiliza detección de colisiones, si para llegar al destino hay una red de cobre o fibra … el router hará la reestructuración de los paquetes para que pasen a tener Y tamaño y utilizar otro método de evitar colisiones como puede ser el paso de testigo  Transporte: Se encarga de que 2 programas/procesos se comuniquen entre sí, identificar qué programas deben comunicarse. Hay 2 protocolos principales que son TCP protocolo confiable que procura que la información llegue al destino o UDP no se garantiza que la información no llegue al destino, pero más rápido que TCP. En este nivel los procesos se identifican por la IP + Nº puerto, el UDP solo aporta los puertos de origen y de destino, siendo este protocolo más rapido que TCP pero menos fiable. TCP es más seguro debido a que enumera las tramas que se transmiten, añade un campo al paquete con la enumeración, el receptor al notar la falta de un paquete lo vuelve a solicitar. Los paquetes no tienen porque llegar al mismo orden por lo que si al receptor le llegan desordenados este es capaz de ordenarlos. Estos procesos es por lo que lo hace lento a diferencia de UDP. El puerto de origen identifica al programa que ha iniciado la conversación y el destino el puerto del programa destino. En un mismo ordenador no se pueden utilizar el mismo puerto para dos programas a no ser que uno sea TCP y otro UDP ya que hay 65.000 para TCP y otros 65.000 para TCP  Aplicación: Define la manera en la que un cliente se comunica con un servidor, conjunto de protocolos como HTTP o HTTPS que tienen diferentes comandos/ordener que se envían al servidor. Regula que información se va a mandar y que formato se va a  enviar está. Se define como va a ser la consulta (protocolo-comando), y como se va a transmitir la información  En muchos casos el nivel Físico/enlace se consideran uno solo. Dentro de cada nivel no hay un único protocolo, por ejemplo en el nivel de enlace no es el mismo si se trabaja en una red cableada o inalambrica  Físico/enlace ethernet, 802.11(wifi), 5G(telefonía), Token-Ring(fibra, normalmente redes en anillo…) Red IPV4, IPV6 Transporte TCP, UDP Aplicación HTTPS, HTTP, FTP(transferencia de ficheros), RTSP(streaming), SMTP(correo)  TCP/IP es un protocolo abierto que se construyó por la comunidad, se utilizó un request for comment(RFC), donde la comunidad realizó sus propuestas, estas se estudiaron, se creó el boceto y se volvió a realizar otro RFC hasta que se hizo aceptable  PROTOCOLO DHCP Protocolo que se encarga de asignar las configuraciones TCP/IP a los clientes con la configuración de IP dinámica. Los clientes nada más encender el ordenador realizan peticiones al servidor, la conexión comienza de la siguiente manera  CLIENTE DHCP DISCOVER: Mensaje de broadcast a la rede que vva en busca de un servidor DHCP suponiendo varias opciones que haya un servidor, que no haya ninguno o que haya varios. Un solo servidor: En este caso procedimiento normal (discover, offer, request, ack) Ningún servidor: Se intentan varios discover, normalmente has 4 en caso de no recibir ningún OFFER los propios clientes se ponen una ellos mismo utilizando dependiendo del SO se utiliza APIPA o AVAHI. Las direcciones son 169.254.0.0/16 antes de colocarse la IP pregunta a la red 169.254.X.X si está libre en caso de que no pues pasa a la siguiente así hasta que esté libre. Esta solución permite comunicar los ordenadores que hayan tenido el mismo problema, lo que no van a poder salir a internet Varios servidores: Pueden dar direcciones de la misma red o de diferentes redes. De ser el primer caso pueden dar direcciones repetidas. Lo normal al tener varios servidores es que falle media red aproximadamente y una mitad no tenga conexión con la otra  SERVIDOR OFFER: Le envía un paquete mostrándole la configuración TCP/IP siendo un mensaje de punto a punto y no de broadcast CLIENTE DHCP REQUEST: El cliente le indica que acepta la configuración y le reserve esa ip SERVIDOR ACK: El servidor le envía la configuración de la oferta y le reserva la IP a esa maquina (ACK=ACKNOWLEDGEMENT=CONFIRMACIÓN)  Te prestan la configuración por un tiempo concreto (Lease Time) Se pueden establecer reservas de IP en el servidor DHCP (Ips fijas para máquinas concretas) Se usan los puertos 67(servidor) y 68(cliente) Controla las IP que quedan libres  PROTOCOLO ARP Address protocol resolution, traduce direcciones IP a MAC. El switch no entiende de IPS solo entiende de nivel de enlace es decir hasta MAC, entonces cuando quiero enviar un mensaje a un ordenador de mi red, el switch cuenta con una tabla con todas las macs de las bocas  ARP Request: Mensaje de difusión que indica “El que tenga esta IP que me diga su MAC” ARP Reply: Mensaje que responde a la petición anterior  PROTOCOLO DNS DNS(Domain Name Service) almacena los nombres de dominios que son la manera de llamar a un ordenador o conjuntos de estos, los nombres de dominios son visibles normalmente en las URL de las webs a las que navegamos. Las url estan formadas por 2 partes www\t.\tgonzalonazareno.org \t\t\t\t\tPC\t\t\tDOMINIO Los DNS traducen direcciones de dominio(URLs) a direcciones IPS. Antes de la creación de estos se almacenaban en un ficheros las webs a las que tú navegabas con las ips correspondientes a estas. Este fichero se llamaba hosts.txt y lo tenias que descargar por ftp Este fichero se actualizaba bastante rápido por lo que había que descargar nuevas versiones y cada vez pesaba más y se llegaba a tardar mucho en descargar. A partir de aquí se decidió mostrar los servidores DNS que son bases de datos jerárquicas donde la información no esta en el mismo servidor sino distribuida en diferentes servidores en todo el mundo y con espejos de todos estos. Los principales servidores DNS son los raiz / y lo que contiene son enlaces con los dominios con las urls principales (.com .org .es .uk) que contiene las IPS de los DNS de primer nivel y estos almacena los dominios de primer nivel   Las URLs se estructuran de la siguiente forma dit.gonzalo.org La primera parte hasta el primer punto identifica la máquina y el resto los niveles DNS   Los DNS no dan la IP del servidor web o el que sea debido a que estos estan en una red local por lo que solo devuelve la ip publica del router, las peticiones son enviadas a este y el propio router es el que se encarga de devolver las consultas  También sirve para identificar las máquinas de dentro de la red ej: servidor de bbdd = 192.168.1.9\to también como caché DNS evitando tener que realizar las resoluciones  Softwares de servidores DNS pueden ser bind9 y trabaja en el puerto 53  Los mensajes del protocolo DNS son 2 DNS Request: La petición de la ip de la URL que se solicita (la petición se realiza a los DNS configurados en mi maquina) DNS Reply: Se responde con la IP publica del router del dominó que se solicitó  Los DNS están configurados en el fichero (/etc/resolv.conf) Cuando el primer DNS no tiene la resolución de la URL este pasa a actuar como cliente y cuando recibe la respuesta esté la añade DNAT Proceso inverso a SNAT es decir de IP publica a privada, cuenta con una tabla donde se almacena el numero de puertos y las maquinas que tienen un servicio con esos puertos por ejemplo 3306\t192.168.0.2 5432\t192.168.0.2 Es una tabla muy parecida a la de SNAT pero no similar SNAT Proceso de traducción de ip privada a pública necesario para poder navegar con IPV4, este proceso se lleva a cabo en el router y almacena la IP de la petición en una tabla llamada snat con el número de puerto y la ip de la máquina  Este proceso se realiza en la petición del router cliente y en la respuesta del router del servidor y al volver simplemente se deshace el SNAT pero no es un proceso de DNAT  PAT(TRADUCCIÓN DE DIRECCIÓN DE RESPUESTA) se basa en modificar el puerto de la petición del cliente debido a que el puerto ya está ocupado y repetido por otro programa de otro dispositivo.  COMO FUNCIONA TCP/IP EN LA REALIDAD En cada nivel se va añadiendo información a los paquetes  MENSAJE CLIENTE APLICACIÓN  Comando de protocolo (GET WWW.MARCA.COM) TRANSPORTE  P.ORIGEN Y P.DESTINO (*|80) Comando de protocolo (GET WWW.MARCA.COM) RED (Para saber la IP destino, parar y realizar petición DNS)  IP.ORG Y IP.DEST (192.168.1.10 | ) P.ORIGEN Y P.DESTINO (2000|80) Comando de protocolo (GET WWW.MARCA.COM)  P.ORIGEN Y P.DESTINO (2000|80) Comando de protocolo (GET WWW.MARCA.COM)  P.ORIGEN Y P.DESTINO (2000|80) Comando de protocolo (GET WWW.MARCA.COM)  PETICIÓN DNS  APLICACIÓN  DNS Request TRANSPORTE                 43258       53           RED                 192.168.1.10       8.8.8.8           ENLACE (COMIENZA PETICIÓN ARP PARA AVERIGUAR MAC GATEWAY)  MAC_ORG Y MAC_DEST (MI_PC | MAC_GATEWAY)  FÍSICO  PETICIÓN ARG MAC_BROADCAST = ff:ff:ff:ff:ff:ff  APLICACIÓN  ARP REQUEST ENLACE                 MAC_PC       MAC_BROADCAST           FÍSICO  ROUTERS CISCOS CUENTAN CON UN PROTOCOLO SIMILAR A ARP QUE ESTÁ SIEMPRE PREGUNTANDO A LOS VECINOS CDP  *Puerto, identificador que asigna el SO a los programas que se ejecutan para comunicarse con otro fuera de mi red local hay 65535 PRIMER PUNTO EJERCICIO SIMULACRO EXAMEN  Se solicita una petición web a un servidor (A-C)  Comenzamos con la creación del paquete de petición web PET web\t\t\t\t\t\t\t(5º mensaje por cable) APLICACIÓN   get URL TRASNPORTE  S.D=4000* P.D=80 get URL RED  IP.S=172.22.1.35 IP.D=pet.DNS S.D=4000* P.D=80 get URL ENLACE MAC.S = cliente MAC.D = gateway IP.S=172.22.1.35 IP.D=pet.DNS S.D=4000* P.D=80 get URL  PET DNS\t\t(3º Mensaje por cable) APLICACIÓN  DNS.REQUEST TRANSPORTE  P.S=2502*(llama a otro programa diferente que el que hace la petición web) P.D=53 DNS.REQUEST RED  IP.S=172.22.1.35 IP.D=8.8.8.8(primario) P.S=2502* P.D=53 DNS.REQUEST ENLACE MAC.S=(cliente) PET.ARP (cuando tiene la mac ya se envia) IP.S=172.22.1.35 IP.D=8.8.8.8 P.S=2502* P.D=53 DNS.REQUEST  PETICIÓN ARP\t(1º Mensaje por cable)\t\t\t\tMSG:ARP request APLICACIÓN  ¿quien tiene la ip 192.168.1.1? Díselo a la maquina x.x.x.x ENLACE MAC.S=mac_cliente MAC.D=ff:ff:ff:ff:ff:ff (broadcast)  RESPUESTA ARP\t(2º Mensaje por cable)\t\t\t\tMSG: ARP reply APLICACIÓN  la ip pertenece a X mac ENLACE MAC.S=equipo_solicitada_anteriormente (gateway en este caso) MAC.D=mac_cliente  RESPUESTA DNS \t(4º Mensaje por el cable)\t\t\t\tDNS REPLY APLICACIÓN  URL is ip_router TRANSPORTE  P.S=53 P.D=2502 URL is ip_router red  IP.S=8.8.8.8 IP.D= maquina_cliente P.S=53 P.D=2502 URL is ip_router enlace MAC.S= gateway MAC.S= mac cliente IP.S=8.8.8.8 IP.D= maquina_cliente P.S=53 P.D=2502 URL is ip_router  RESPUESTA WEB\t\t(6º PAQUETE DEL CABLE)\t\t APLICACIÓN  HTML WEB TRANSPORTE  P.O=80 P.D = 4000* HTML WEB RED  IP.O=IP ROUTER IP.D=172.22.1.35 P.O=80 P.D = 4000* HTML WEB ENLACE MAC_ROUTER CLIENTE IP.O=IP ROUTER IP.D=172.22.1.35 P.O=80 P.D = 4000* HTML WEB  ICMP ICMP no utiliza nivel de transporte  TEMA 3 NIVELES FÍSICO Y ENLACE NIVELES FÍSICOS ¿Que nos podemos encontrar en una instalación física/infraestructura física, tipos de cable, y como se trabaja con ellas desde el punto de vista teórico? Muchas veces vamos a tener que decidir con qué tipo de medio realizar una instalación ya sea medio guiado o no guiado, donde se compra o comercializa Vamos a tratar mucho con switches tanto física o virtualmente en gns3  HERRAMIENTAS Benchmark: Sirve para comprobar la velocidad real de trasmisión iperf / iperf3: Indica la el ancho de banda de una conexion DEFINICIONES Velocidad de transmisión: Cantidad de información que se transmite por unidad de tiempo, se mide en bits por segundo (bps) o en multiplos (Kbps, Mbps, Gbps) 1Kb\t—\t1024 b 1Mb\t—\t1024 Kb 1Gb\t—\t1024 Mb  Ancho de banda: Máxima velocidad de transmisión de la información que ofrece el medio en condiciones ideales (máximo teórico)  Latencia/retardo de propagación: El tiempo que tarda el primer bit transmitido por el origen  en llegar al destino  La latencia y la velocidad de transmisión no están correlacionadas similarmente es decir tener más velocidad de transmisión no es tener menor latencia, no tienen relación  Atenuación: Es una pérdida de potencia gradual de la señal transmitida por el medio, aumenta proporcionalmente con la distancia recorrida y se mide en decibelios o en porcentajes. Normalmente la atenuación en muchos cables suele ser debida por el rozamiento pasando gran parte de la potencia de la señal por calor hasta llegar a un punto en que la señal sea indistinguible  Ruido: Perturbación electromagnética que sufre la señal en una comunicación, se puede producir por muchos motivos. Una señal electromagnética siempre puede tener ruido, debido a elementos naturales como el propio campo magnético de la tierra, tormentas solares o componentes electrónicos (amplificadores, circuitos etc) y no todos los componentes tienen una señal igual de tenue que otras. También por elementos externos como motores y tubos fluorescentes … para evitar estos problemas o disminuirlos ha normativas específicas  Para evitar el ruido podemos dejar de trabajar con electricidad y trabajar con pulsos de luz ya que la fibra óptica no se ve para nada afectada a los campos eléctricos   Ancho de banda garantizado: El mínimo de ancho de banda en el peor de los casos  EJERCICIO Un amigo me ha pedido que le pase una película que ocupa 4GB. Su casa está a 5 minutos de la mía andando. Mi conexión a Internet tiene un ancho de banda de 300Mbps, aunque la velocidad de transmisión real es de aproximadamente 30% del ancho de banda  ¿Será más rápido llevarle el pendrive con la peli o mandarla por internet?  ¿Cuál será la latencia en cada caso?  Andando: Velocidad de transmisión (Vtx) = 4GB /300 seg 1GB son 8Gb 4GB pasan a ser 32Gb  32Gb (*1024)-&gt; 32768Mb / 300 segundos -&gt; 109.23 Mbps  Por Internet: 300Mbps * 30 / 100 = 90 Mbps  En primer bits andando tarda los 5 minutos del camino a la casa   Normalmente a la hora de transmitir gran cantidad de datos como puede ser copias de seguridad no me va a importar la latencia mientras la velocidad de transmisión sea mayor, sin embargo a la hora de realizar alguna actividad interactiva si nos interesa tener una latencia muy pequeña  Por ejemplo en algunos medios como puede ser el aire en tarjetas inalambricas es posible que en el momento en el que comienza a transmisión no escucha por lo el destinatario es el unico que se da cuenta de que se han chocados paquetes por lo que los vuelve a pedir sin embargo en otros medios como algun medio guiado en caso de que haya una colision estos si pueden ser capaz de darse cuenta y para volver a transmitir se espera un tiempo aleatorio  TRANSMISIONES ANALÓGICAS Y DIGITALES  Las señales analígicas representan funciones continues es decir en el rango que se transmiten por ejemplo 0V y 5V puede representar cualquier valor entre ese rango esto con el ruido y la atenuación la señal original cambia y el destinatario no es capaz de saber el valor de la señal original  Las señales digitales representan funciones discretas es decir no puede coger cualquier valor sino unos limitados por lo que el destinatario es capaz de reconstruir la señal original. En estos casos por ejemplo un cable UTP a los 100 metros incluso estas señales no son reconocibles ya que no se puede distinguir si la señal a esa distancia es un 5V con atenuación o un 0V con ruido  FIBRA ÓPTICA Monomodo: El núcleo es tan pequeño que la luz no puede desviarse teniendo un alcance muy grande Multimodo: Permite que la luz se propague en diferentes direcciones, el núcleo tiene un índice de refracción diferente al del revestimiento por lo que la onda de luz se propaga rebotando en las paredes del revestimiento Salto de índice: El cambio de refracción entre el revestimiento  el núcleo es muy grande Salto de gradiente de índice: El cambio de refracción se realiza poco a poco   EJERCICIO Un fichero de 4.7GB ha tardado en transmitirse 12 minutos ¿Cuál ha sido la velocidad de transmisión?  Datos: Cantidad de Información y Tiempo Incógnita: Vtx  Segundos 12 * 60 = 720 segundos  Cantidad de información 4.7GB 4.7 * 8 = 37,6Gb * 1024 = 38502,4Mb 720\t38502,4 1\tx Velocidad de transmisión por segundo=38502,4/720=53,47Mbps  Cuanto tarda en transmitirse por una red wifi 802.11ac un fichero de 12GB si la velocidad de transmisión ha sido de un 40% del ancho de banda  Datos: Vtx y Cantidad de información Incógnita: Tiempo Cantidad de información= 12GB *8 = 96Gb * 1024 = 98304Mb Velocidad de transmisión (40% de ) 1.300 Mbps. * 40 = 5200 / 100 = 520 Mbps 520\t1 98304\tx Tiempo= 98304 / 520 =  189 segundos / 60 = 3,15 segundos  ¿Qué cantidad de información puede transmitirse en una hora por un dispositivo móvil usando bluetooth 3.0?  Datos: Tiempo y Vtx Incógnita: Cantidad de Información  Ancho de banda 24Mbps Velocidad = 60 min = 3600 segundos 24Mb\t1 segundo X\t3600 segundos Cantidad de información transmitida en una hora: 24 * 3600 = 86400 Mbps / 1024 = 84,375Gbps / 8 =10,54 GBps VELOCIDADES MEDIOS Redes cableadas FastEthernet: 100Mbps Gigabit Ethernet: 1Gbps 10GB Ethernet: 10Gbps  Redes inalambrica 802.11 a/b/g/h/ac/ax Bluetooth 3.0 4.0 5.0  Par paralelo: Categoría 1 conector rj-11 con 4 cuchillas pero solo se utilizan 2  El cableado vertical  o backbone es el cableado que conecta las plantas  NIVEL ENLACES Los switches se pueden componer de de 24, 48 bocas y estos tienen precios muy parejos casi siempre, con ellos se pueden crear una red local pequeña de no más de 48 nodos por switch, de forma que si quiero más nodos necesito varios switches, por ejemplo  Crear una red de 90 ordenadores, para ello conecto 45 ordenadores a cada switch y +1 boca para interconectar los switches   En el caso anterior si los switches y el los cables trabajan en 1Gb, todas las maquinas de un mismo switch si se pueden comunicar a 1Gb por segundo pero si varias maquinas de un switch se quieren comunicar con otras del otro switch el cable que conecta ambos switch debe de repartir el ancho de vanda en caso de dos maquinas de switch a para 2 maquinas de switch b el ancho de banda será de 512 Mbps y en disminución en caso de que haya más conexiones  Ahora queremos salir a internet y conectamos un router al switch a  Después de este cambio los ordenadores del switch a tendrán más ancho de banda que los del switch b  En vez de 90 ordenadores 200 ordenadores  Necesito 5 switches y los voy a conectar en cascada, 40 ordenadores en cada switch y un switch conectado a otro, esto no esta permitido ya que como máximo se pueden tener 2 niveles en cascada y no 5 ya que en el peor de los casos es decir los 200 ordenadores queriendo salir a internet swich a (41 bocas usadas): Hay que dividir el ando de banda entre las bocas 1024 / 41 = 25Mbps switch b (41 bocas para 25 Mbps disponible): Hay que dividir 25Mbsp entre otras 41 bocas 25/41= 0,6Mbps switch c (41 bocas para 0,6Mbps disponible): Hay que dividir 600Kbps/41=15Kbps switch d (41 bocas para 15Kbps): 15/41=400bps switch e (41 bocas pra 400bps): 400/41=10bps  Por estos casos no se pueden poner más de 2 niveles ya que con 10 bps no se puede hacer prácticamente nada  También podemos tener más problemas debido a tener más swiches, si estos están en un lugar inadecuado al alcance de personas no autorizadas, estos pueden llegar a crear una tormenta de broadcast conectadon un switch a otro switch en ambos extremos por ejemplo switch_a_boca_1 con switch_b_boca_1 y lo mismo con la poca 2 de ambos este caso puede crear un bucle y saturar el ancho de banda hasta tirar la red  Lo normal para evitar los altos niveles en cascadas, se recomiendan switches de cabeceras, este switch no va a tener ninguna máquina conectada a este más que los servidores, routers, AP y los demás switches. Con este método se evita la jerarquía y todos los switches conectados al de cabecera tienen la misma capacidad de ancho de banda.    Si queremos la red de 200 máquinas en la imagen anterior para hacerlo bien necesitaremos un switch de segundo nivel más, para hacer bien  Port Bonding(general)/Trunking(CISCO)/Link Aggregation: Procesos por el que se utilizan para utilizar 2 conexiones como si fueran uno doblando el ancho de banda de las conexiones (no es el doble ya que surge tráfico para vincular los cables pero casi el doble). En la imagen anterior puedo hacer un bonding de 2 bocas en cada switch ya que el de cabecera tiene libre muchas bocas, con esto la conexion parasará de 1Gbps a 2Gbps practicamente Ventajas: Más ancho de banda, normalmente bonding de 2,4,8 Desventajas: Menos bocas  En un servidor se pueden agregar tarjetas de red y hacer tambien bonding  IMPORTANTE NO TENER CUELLOS DE BOTELLAS YA QUE TODA LA INFRAESTRUCTURA SE ADAPTA A LA VELOCIDAD MÍNIMA  Otra opción es utilizar switch que cuentan con bocas de fibra por lo que no haria falta poner bonding por las bocas normales de switch utilizando estas bocas ya se podría utilizar 10Gbps estos switches se identifican (48 + 2 / 48+4)  Otras opciones son los switches apilables, estos switches se caracterizan por tener en la parte trasera dos puertos denominados stack in /stack out ó stack up / stack down. Estos puertos en función del fabricante tienen un formato u otro, la cantidad de switches que se pueden apilar también dependen del fabricante normalmente 8  Se conectan cada in en el out del siguiente y el último in en el out del primero  Estos cables suelen ser de fibra o llamados fiberchannel que pueden ir entre 40-80 Gbps  A efectos practicos es como tener un unico switch  Otra opción es utilizar un Blade switch o switch modular este switch se le van añadiendo las ranuras de las bocas o modulos, parecido a un rack o los discos duros de los servidores, estos dispositivos tambien traen un software para configurarlo Ventajas: Los switches estan conectados todos a una placa base por lo que será el mismo Desventajas: Muy caros  *BARGAIN HARDWARE web con maquinas reacondicionadas *  CARACTERÍSTICAS AL COMPRAR SWITCH PoE: Power over Ethernet: alimentación por ethernet, utilizando un cable utp se puede alimentar al switch por 2 hilos  2x1100W: Indica 2 fuentes de alimentación  Managed switch: Switch gestionable para poder realizar ciertas configuraciones  El protocolo de spanning tree Algorithm o Planning tree protocol es un protocolo encargado de anular los bucles para evitar las tormentas de broadcast (SPA/SPN/STP)  REDES VIRTUAL (VLANS) Solo en switches gestionados (managed switch/ smart switch), en estos switches se pueden hacer port bonding, port mirroring, quality of service (qos). Algunos switches tienen características de nivel 3 es decir de nivel de red \tVLANS Permiten dividir la red local en redes virtuales, es decir puertos a-b primera red virtual y de c-d otra. Con esto se separan las máquinas y estas no tienen conexión VLANS asimétricas: Estas VLANS son las que cuentan con puertos que pertenecen a varias VLANS  Tengo 4 switches, cada switch en un aula, menos uno de cabezera. El de cabezera tiene tres bocas para 3 servidores y una boca para el router. Los switches estan conectados al de cabecera con un bonding de 2 bocas.  Primer switch las trentan máquinas (3-32) de 1º grado medio y 15 de 2º SMR Segundo de switch (3-12) 2º SNR  15 1º de asir y las ultimas 4 bocas 2º asir Tercer switch (3-7), 2º asir y el resto de bocas libres    Tapped/Untapped ports: Un puerto etiquetado es aquel que añade una cabecera a los mensajes para indicar a qué vlan pertenece (802.1q), con esto se distinguen las vlans independientemente si la información va a otro switch. Todas las bocas que conectan otros switches hay que etiquetarlos.  Puerto de monitorización/espejo/port mirroring: Puerto que reenvía todo el tráfico que va por todas las bocas,  a una boca concreta a la que se conecta una máquina que analiza el tráfico. Normalmente se miran las estadísticas de switch antes que poner una máquina con wireshark ya que se ven las estadísticas del tráfico. A Veces las estadísticas de tráfico no muestran algo concluyente y entonces si conectamos la máquina con wireshark.  Hay switches que son capaces de decirte la velocidad de las conexiones, y la distancia del fallo   Para saber a que boca de switch está conectada una máquina, normalmente se mira las etiquetas que se asigna a la roseta que te indica el patch panel armario y puerto.  En el diseño de la infraestructura, la cantidad de armarios y switches se debe de ampliar un 30% mas del uso total que se tiene previsto  QoS: Se centra en priorizar una cosa u otra a nivel general de informatica, en el caso de redes con los switch, le puedo dar prioridad a una boca sobre otra de forma que primero atiende el trafico de las bocas prioritarias antes que las de los demás, tambien sobre un tipo de trafico por ejemplo el trafico http o el trafico con destino dropbox tiene menos prioridad que otro   ESPECIFICACIONES DE CISCO Puertos access: Puertos en el que se espera conectar una maquina corriente Puertos trunk: Puertos que se espera conectorizar otros switches Port channel: Utilizar varias bocas para conectorizar similar a los port bonding de otros routers como los D-Link   NAT  SNAT: Se cambia la ip de origen con la ip publica del router u otra IP. En caso de que los puertos de ambas maquinas coinciden, se realiza PAT que es la sustitución de los puertos en el trafico por parte del router DNAT: Se cambia la ip de destino, nos permite que en un equipo externo a nuestra red pueda acceder a los servidores de mi red local.  El cliente al salir hace SNAT al recibirlo el router del servidor se hace DNAT, la respuesta generada por el servidor debe de hacer SNAT ya que la respuesta parte con la ip privada de la maquina y no la publica del router y finalmente se deshace el SNAT original porque que la petición contaba con la IP de origen publica y la respuesta tiene como destino la IP publica tambien por lo que el router deshace el SNAT  SNAT REGLAS up …….. Cuando se levante la interfaz se ejecutan las regla de iptables  up iptables -t nat -A POSTROUTING -s IP_RED_LOCAL -o INTERFAZ_IP_PUBLICA -j SNAT –to IP_PUBLICA  down ……. Cuando se va a bajar la interfaz down iptables -t nat -D POSTROUTING -s IP_RED_LOCAL -o INTERFAZ_IP_PUBLICA -j SNAT –to IP_PUBLICA -t: Tabla -A: Añadir cadena -D: Eliminar cadena -o: Interfaz de salida (output) -j: Acción que vamos a hacer (SNAT, DNAT, MASQUERADE)    -to: A que IP se va a traducir (solo en snat y dnat)   En la tabla NAT hay 2 cadenas POSTROUTING: Después de haber tomado una decisión de enrutamiento, SNAT es siempre o casi siempre POSTROUTING ya que no es posible hacerlo hasta que no sepa que interfaz de salida va a utilizar por lo que primero se mira/realiza el enrutamiento y despues se aplica la regla PREROUTING  En caso de tener una IP publica dinamica se utiliza la orden MASQUERADE  down iptables -t nat -D POSTROUTING -s IP_RED_LOCAL -o INTERFAZ_IP_PUBLICA -j MASQUERADE  DNAT –p: Protocolo    -dport: -i: interfaz(input)   up iptables -t nat -A PREROUTING -p tcp –dport 80 -i eth0 -j DNAT - -to IP_privada  SNAT CISCO En cisco hay que permitir con una ACL con las IPs que tienen permitidas realizar SNAT  (config)access-list nºacl permit ip wildcard (config)ip nat pool IP_PUBLICA   CORTAFUEGOS Con un cortafuegos podemos permitir analizar el trafico de red al atravesar un dispositivo y tomar decisiones acerca del mismos permitir el paso denegar el paso silenciosamente o no modificar el trafico seleccionar determinado trafico para otra aplicación  Se usa por seguridad para controlar o modificar el trafico de la red  Los cortafuegos se pueden poner de 2 formas  NODO Un cortafuego de nodo protege un solo equipo, normalmente un servidor, es muy laborioso cuando se tiene muchos servidores, pero cuenta con ventajas de protección tanto para ataques externos e internos  PERIMETRAL Un cortafuegos que se coloca entre el router y el switch o en caso de ser software el propio router lo tiene integrado, los cortafuegos hardwares son más veloces a la hora de procesar el tráfico  DMZ una zona desmilitarizada es una zona de mi red que permite cierto acceso a internet, para esto se utiliza un cortafuegos de 3 patas donde el cortafuego dependiendo de que a que maquina se dirige el trafico se aplica ciertas reglas u otras    Dentro de la tabla filter hat 3 cadenas INPUT OUTPUT FORWARD  Para establecer una politica por defecto iptables [-t tabla] -P cadena ACCEPT | DROP -P: Policy, politica  Por cada cadena hay que establecer una política por defecto  iptables [-t tabla] -L [cadena] -n -v Lista las reglas                 iptables -A [cadena] -p protocolo -s ip_origen/red -d ip destino -i interfaz interda -o interfaz salida -j accept       drop           -j: Accion a realizar si acepta o dropear  -p: Indicamos el protocolo, si se especifica tcp se permite utilizar    -dport: puerto de destino   -sport puerto de origen   -s: ip origen -d: ip destino -i: interfaz entrada -o: interfaz de salida                 state            Los parametros con un - son basicas mientras – indica parametros avanzados por lo que hay que cargar el modulo -m  -j REJECT rechazo confirmado similar a DROP pero este no confirma  iptables cuentas con muchos modulos y casi siempre hay que cargarlos -p protocolo -m protocolo –parametro_modulo en el caso de el modulo TCPy UDP ES DE LOS POCOS QUE SE CARGAN POR DEFECTO  MODULOS IPTABLES addrtype: Sirve para cargar el tipo de dirección IP especifica como puede ser unicast multicast broadcast -m addrtype – {dst|src}-type broadcast comment: Sirve para poner comentarios en el propio comando de ejecucion -m comment –comment “Primero cargamos el modulo y utilizamos el parametro comment” connlimit: Limita el numero de conexiones paralelas desde un mismo cliente -m connlimit –connlimitº-above 3  icmp: Utilizamos el protocolo ICMP -m icmp –icmp-type echo -request conntrack –state  iprange: indicamos un rango de ips -m iprange mac: Modulo para trabajar con macs -m mac –mac-source || –mac-destination multipor: Permite establecer un rango de puertos time: Definimos un tiempo -m time –timestart 13:30 –timestop 14:30 –weekdays  COMANDOS hping3: Sirve para generar tramas personalizadas telnet: sirve para comprobar si un puerto esta activo  nmap: Siver para hacer un “mapa de la red” y conocer los servicios disponibles a demás de realizar ciertos ataques   ENCAMINAMIENTO DINÁMICO Se le asigna un valor de “coste”  a las rutas escogiendo la de costes mas “baratos”, sin importar el tiempo o la optimización de saltos de routers, este metodo es normal para las compañías de teleco que miran por los costes más baratos  Cada router pregunta a sus vecinos a donde saben llegar y qué coste tienen, a partir de aqui realiza las tablas de enrutamiento   Utilización de algoritmo de DISTRAC   Hay varios protocolos de encaminamiento dinámico pero ambos cuentan las siguientes características comunes Minimizar el tamaño de las tablas de encaminamiento Minimizar el número de mensajes de control a intercambiar Generar rutas correctas, optimas en coste y uso del ancho de banda disponible sin discriminar a ningún nodo Modificar las rutas en rapidamente en caso de fallos en alguna ruta o de cambios en las condiciones del tráfico  Ser escalable, es decir que no se vuelva inviable cuando la red crezca, dicho de otra forma   Los costes se pueden calcular en función de algo, como puede ser el ancho de banda, latencia, coste económico, número de saltos…  PROTOCOLOS DE VECTOR DE DISTANCIA Son muy ligeros en el consumo de recursos, pero en las averías tardan en comunicarse y es posible que ciertos routers se queden sin saber que hay una averia (PROTOCOLO RIP)   Usa UDP   PROTOCOLO DE ESTADO DE ENLACE Las averias se propagan rapido, se pueden combinar varios parametros para calcular el coste y a tiempo real Permiten obtener rutas alternativas para un mismo destino Cada nodo tiene información de toda la estructura del resto de la red y calcula por si mismo su tabla de enrutamiento  Desventajas Algoritmos complejos Requiere almacenar en cada nodo una gra cantidad de información Los mensajes que intercambia los routers pueden   OSPF – IS-IS"
  },
  
  {
    "title": "Iso Apuntes",
    "url": "/posts/ISO-APUNTES/",
    "categories": "",
    "tags": "",
    "date": "2025-10-20 00:00:00 +0200",
    "content": "ÍNDICE  [Definiciones4]  [FICHEROS/DIRECTORIOS IMPORTANTES4]  [DIRECTORIOS RAÍCES4]  [APUNTES PROPIOS7]  [ATAJOS DE TECLADO Y TRUCOS7]  [COMANDOS8]  [VARIABLES12]  [Temario13]  [Tema 113]  [PERMISOS14]  [TIPOS DE FICHEROS14]  [EXPANSIÓN DE NOMBRES DE FICHERO14]  [EXPRESIONES DE NOMBRES COMPLEJAS15]  [EXPRESIONES LÓGICAS15]  [EXPANSIÓN DE COMANDOS16]  [CLAVES PÚBLICAS-PRIVADAS17]  [CARACTERES DE PROTECCIÓN I17]  [COMILLAS SIMPLES18]  [CARACTER \\ SLASH18]  [COMILLAS DOBLES18]  [OPERADORES18]  [OPERADOR “Y” LÓGICO: &amp;&amp;18]  [OPERADOR “O” LÓGICO19]  [OPERADOR “;” LÓGICO19]  [AGRUPACIÓN DE COMANDO19]  [GENERACIÓN DE MÚLTIPLES FICHEROS 119]  [ALIAS20]  [ENLACES BLANDO / SOFT LINKS20]  [ENLACES DUROS  / HARDLINK21]  [REDIRECCIONES21]  [Redirecciones simples22]  [Redirecciones dobles22]  [Redirecciones de entradas simples22]  [Redirecciones de entradas dobles22]  [CANALES ESTÁNDARES23]  [APERTURAS DE CANALES 3-924]  [TUBERÍAS O PIPELINES24]  [Tuberías Con Nombres25]  [COMANDO TEE25]  [COMANDO XARGS26]  [COMANDO FIND27]  [COMANDO LOCATE29]  [GREP29]  [RENAME31]  [SED32]  [SED-ACCIÓN32]  [SED-DIRECCIÓN SIMPLE32]  [SED-COMANDOS33]  [d (delete)33]  [p (print)33]  [= (Mostrar)33]  [! (negación)33]  [s (sustitución)33]  [w (write)33]  [a (anexar)34]  [i (insertar)34]  [c (reemplazar)34]  [CUT35]  [TR35]  [AWK35]  [AWK, VARIABLES35]  [AWK, ACCIÓN-AWK PRINT36]  [SISTEMAS DE FICHEROS/ARCHIVOS37]  [Supuesto practico137]  [Supuesto practic o237]  [HERRAMIENTAS SISTEMAS DE FICHEROS37]  [TABLA DE INODOS37]  [DIRECCIONES INDIRECCIONES DE INODOS38]  [dumpe2fs38]  [ext3grep38]  [CREACIÓN DE UN SISTEMA DE FICHEROS39]  [UEFI SHELL39]  [SWAP40]  [JOURNALCTL43]  [GRUB EFI INITRAMFS43]  [PROCESOS43]  [SESIONES45]  [SCRIPT48]  [PASO DE ARGUMENTOS AL SCRIPT49]  [ENTRADA DE DATOS MANUALMENTE AL SCRIPT49]  [ESTRUCTURA CONDICIONAL IF51]  [Condiciones sobre cadenas de texto51]  [Condiciones sobre numericos51]  [Condiciones sobre ficheros51]  [OPERADORES LÓGICOS52]  [AGRUPACIONES52]  [COMANDO [[ ]]52]  [COMPARACIÓN DE CADENAS MEDIANTE PATRON53]  [ESTRUCTURA IF54]  [LIBRERAS54]  [getops55]  [BUCLES55]  [SENTENCIA CASE55]  [Ficheros56]  [DEPURACIÓN DE SCRIPTS56]  [DIALOG57]  [USUARIO ESPECIALES58]  [WINDOWS59]  [bcdedit editor de configuración de arranque61]  [POWERSHELL61]  [ACTIVE DIRECTORY62]  Definiciones          Sistema informático: Conjunto de hardware y software           Hardware: Parte fisica del sistema informatico (Raton, pantalla…)           Software: Parte no física (Programas, aplicaciones…)           Drivers o Controladores: Software específico que comunica el hardware y el software           Kernel: Núcleo de los SO GNU/Linux           Firmware: Software básico que controla las funciones de los componentes electrónicos del equipo           Máquina Virtual: Emulación de SO           Hipervisor: Software que permite comunicar las MV con el hardware           Contenedor (Docker / gubernetes): Máquina virtual ligera, que solo emula una cosa para evitar utilizar una gran cantidad de recursos a diferencias de las MV           Form: Distribuciones basadas en una principal pero modificadas para estar especializadas en algunos temas concretos, por ejemplo:(Debian-Kali,Parrot)           Fable: Distribución como el form pero depende más del SO principal           LTS: Soporte a lago tiempo, para SO estables           Caché: Almacena datos que se van a utilizar más probablemente en el futuro, concediendo más velocidad           Abastecimiento liviano LVM: Almacenamiento dinámico, yo le especifico el tamaño y conforme lo vaya necesitando lo va cogiendo, no los reserva directamente del disco           INITRAMFS: Añadidos al arranque que contiene módulos para el kernel           Frase de paso: “Contraseña” para controlar el uso de mi clave privada, evitando que alguien que tenga mi sesión no pueda utilizarla solicitando la frase de paso para las conexiones, parecido a “sudo”, solicita la frase de paso cada x minutos      FICHEROS/DIRECTORIOS IMPORTANTES  DIRECTORIOS RAÍCES          /boot: Contiene todos los archivos esenciales para iniciar debian, cada vez con menos frecuencia el directorio se almacenan en una partición separada, por varios motivos                      La BIOS antigua no podía leer el sector más alla de cierto cilindro, no es el caso de EFI                       El cargador de arranque no entiende la partición / RAID /  de sistemas LVM utilizanco la partición /                   Dentro de el directorio encontraremos 4 archivos para cada versión de kernel que encontremos          vmlinuz-”Vesion_kernel”: Binario actual del kernel           initrd.img-”Version_kernel”: Pequeño sistema de archivos raiz temporal que solo se utiliza para el arranque del sistema. Toma el control desde el cargador de arranque (grub, lilo, etc…), carga controladores esenciales y realiza tareas esenciales para el arranque           config-”Versión_kernel”: contiene opciones de configuración con las que se compiló el kernel (como referencia)           system.map-”version_kernel”: Contiene nombre de simbolos y direcciones del binario del kernel de linux, su nico uso real es para depurar y no es esencial en el resto del tiempo      También podemos encontrar subdirectorios como grub, chos,emile, efi … estos varían en función del cargador de arranque que tengamos          /dev: Contiene los archivos especiales del dispositivo para todos los dispositivos, estos son creados durante la instalación y más tarde con el /dev/MAKEDEV. El /dev/MAKEDEV.local es un script escrito por el administrador del sistema que crea dispositivo solo local archivos o enlaces (es decir aquellos que no forman parte de la norma MAKEDEV), como los archivos de dispositivos para algunos controladores de dispositivos no estándar           /etc:Directorio que almacena subdirectorios o archivo relacionados con la configuración del sistema o servicios. Siempre que se instala una nueva aplicación, los archivos de configuración se conservan aquí por defecto           /bin: En debian como tal no es un directorio sino un enlace a /usr/bin que contiene ejecutables esenciales para la funcionalidad básica del sistema, los binarios almacenados en este directorio son utilizable por todos los usuarios, el administrador, root y el sistema           /sbin: Similar a /bin pero este contien binarios que solo el sistema, el administrador o root pueden utilizar, tambien es un enlace a /usr/sbin           /home:Alberga directorios específicos de los usuarios. Estos directorios son los directorios de trabajo de los usuarios del sistema que tienen permiso de login a excepción de root           /media:           /mnt:           /opt:           /proc:           /root:           /run:           /srv:           /sys:           /tmp:           /usr: Esencial para gestionar eficazmente los recursos del sistema, acceder a binarios y archivos específicos del usuario. Contienen archivos y directorios que no son necesarios para la funcionalidad básica del sistema sino que son esenciales para ejecutar software instalado y soportar operaciones específicas del usuario. Estos son algunos aspectos claves del directorio           Finalidad y estructura: Generado para mantener archivos y directorios no necesarios para arrancar el sistema. A menudo se monta como una partición separada para la flexibilidad en la gestión de los recursos del sistema. Cuenta con subdirectorios ordenados jerárquicamente específicos para cada función /usr/bin para los binarios de usuarios, /usr/lib para las bibliotecas compartidas, /usr/share para los datos compartido y /usr/include para los archivos de cabecera           Subdirectorios en /usr:                      /usr/share: Archivos de datos independientes de la arquitectura, como pueden ser documentación e iconos                       /usr/lib: Bibliotecas requeridas por el software instalado                       /usr/local: Se utiliza para software y archivos que son especificos de la máquina local, no estań gestionados por el gestor de paquetes de la distribución                       /usr/src: A menudo contiene el código fuente de los softwares instalados permitiendo a los usuarios examinarlos y modificarlo                  Los administradores y usuarios pueden obtener una comprensión más profunda de la organización del sistema y localizar archivos o recursos específicos cuando sea necesario     /var: Almacena datos como artículos de noticias, correos electrónicos, sitios web, bases de datos, la caché del sistema de empaquetado.   Estos datos cambian cuando el sistema se ejecuta normalmente, son específicos para cada sistema por lo que no se puede compartir por red           /etc/sudoers: Fichero de sudoers           /etc/apt/sources.list: Fichero con los repositorios           /etc/motd: Fichero para expresar comentarios para inicios de sesión por terminal           /home/usuario/.ssh: Se pueden alojar las claves públicas-privadas de conexiones ssh, puede no estar creado y debemos de crearlo manualmente           /home/usuario/.ssh/known_host: Almacena los hash de las máquinas ssh al que se han conectado (después de confirmar el fingerprints), para saber qué máquinas son.            /var/cache/apt/archives/: Directorios que almacena los archivos .deb descargados de los repositorios, estos archivos contienen todo lo necesario del paquete luego una vez obtenido el sistema se encarga de extraer su contenido y este paquete queda “inservible”            /etc/services: Fichero informativo que muestra el servicio, el puerto que utiliza junto con el protocolo y una breve descripción de estos           /usr/share/man: Contiene directorios de los lenguajes disponibles del manual y los tipo de manuales disponibles           /etc/ssh/ssh_config:Archivo de configuración de ssh con una serie de parámetros como si permitir el acceso por contraseña número de puertos túneles …       APUNTES PROPIOS  En el sistema podemos encontrar diferentes usuarios a demás de root y el usuario propio, estos usuarios pueden ser avahi, raíz, syslog, messagebus, nadie, ntp, rtkit y whoopsie a diferencia de los usuarios como root estos son demonios del sistemas y representan los procesos ejecutados por init system si miramos el archivo /etc/passwd podemos ver que estos usuarios estan incluidos pero al final de la linea de estos donde se define la shell de los usuarios estos solo poseen /usr/sbin/nologin o /bin/false  ATAJOS DE TECLADO Y TRUCOS  REINICIO ORDENADOR == Ctrl + ALT + Imp pant +R+E+I+S+V  MODIFICAR GRUB PARA ABRIR CON TERMINAL EN ROOT: Necesitamos estar en el menú de grub, y hay una opción de edición de grub normalmente pulsando la e EN ESTE MOMENTO TENEMOS TECLADO ANGLOSAJON.  Después buscar la linea del kernel que suele contener vmlinuz y en en ella se indica que el arranque es readonly (ro) y modificamos por rw init=/bin/bash  INDICAR A GRUB QUE DETECTE OTROS SO: editar el archivo /etc/default/grub y buscar una línea donde indique OS_PROBE esta es la encargada de detectar los diferentes SO instalados y de añadirlos en el menú de arranque. Finalmente debemos de actualizar el grub  Concatenación de comandos: Se pueden concatenar comando en una unica linea “;” con ; se ejecuta el primer comando y luego el segundo con &amp;&amp; se ejecuta el primer comando y si tiene exito el segundo   Retroceder: En vez de realizar Ctrl + z desde la consola se debe de utilizar Ctrl + Shift + “-”  Crear un fichero de texto sin touch o herramientas similares utilizamos :&gt; nombre.txt o simplemente con la &gt;   Ctrl + d indica la finalización de introducción de texto  Ctrl + x + e abre un editor de texto, el archivo está en memoria y desde la terminal de bash se guarda en el archivo, desde terminator no    COMANDOS  COMANDO [ PARÁMETRO (- –) ] [ARGUMENTOS]          Uname: Muestra cierta información del SO como el kernel           help: Muestra los comandos internos o en combinación de otro comando, muestra su ayuda           Tasksel: Lista las interfaces gráficas disponibles a instalar, las task son las interfaces           whereis: Devuelve las PATH para saber donde se encuentra los binarios           History: Comando que te indica los comando utilizados, estos se almacenan en el .bash_history           man: Muestra el manual de un comando o variable           useradd: Añade o crea un usuario           Type: Devuelve el tipo de comando (externo interno), funciona tambien con funciones indica que función es y muestra su código           apt show: Muestra información de un paquete que no está instalado            echo: Imprime información con -e da formato al texto \\n intro \\t tabulación…           file: Indica el tipo de fichero           df -h: Muestra información sobre el sistema de ficheros           !!: Ejecuta el último comando ejecutado, Si queremos ver el comando que va a ejecutar !! pulsamos CTRL + ESQ + e           !numero_comando: Ejecuta el comando x almacenado en el histórico, CTRL + ESQ + e para editarlo           less: Paginador, necesita un input que se lo podemos pasar a través de una tubería           tree: Lista contenido de forma de árbol             -p: Muestra los permisos                chmod: Modifica o asigna permisos a los directorios o ficheros           :&gt; : Podemos crear ficheros vacios           &gt; : También crea ficheros vacios           mkdir: Crea directorios                      -m 777 directorios: Creamos los directorios con permisos específicos                       -p path/to/directory: Crea las carpetas necesarios para crear la ruta                       cp fichero ruta destino                      -i: pide confirmación                       -r: Copiado recursivo de una carpeta y todos sus subniveles                       -a: Igual que -r pero si conserva los permisos                       -f: Fuerza la copia                       -u –update: Copia el archivo sólo si el original es más reciente                       -p: Preservar los permisos y fechas                       mv: Mover y renombrar ficheros                      mv fich1 fich2 cambio de nombre                       mv fich1 /prueba/fich1 mover el fichero                       mv fich1 /prueba/fich2 cambio de nombre y mueve el fichero                       -u                       ssh: Permite la conexión remota por terminales              -i: Permite utilizar la clave privada para conexiones con claves públicas-privadas                ssh-keygen: Genera un par de claves pública-privada de conexión ssh           ssh-copy-id: Copia la clave pública en el directorio ~/.ssh/ del servidor generando un archivo de authorized_keys que almacena estas claves           ssh-copy-id: Puede copiar la clave pública o privada en el servidor           ssh usuario@IP ‘comando’: Ejecuta el comando en la máquina remota           ssh-agent: Sirve para que se recuerde la frase de paso de la clave privada en una subterminal, solicita la frase de paso una vez y la almacena en memoria hasta que se cierre la sesión           uptime: Devuelve el tiempo que tiene encendida la máquina           pstree: Muestra de forma arborescente los procesos             -sp ID_proceso: Muestra el proceso y los subprocesos de este                                           ps -aux           grep nombre_a_buscar: Muestra los procesos filtrados con el grep y el ID de estos                                du:           apt clean: Borra todo lo que se encuentre en el directorio /var/cache/apt/archives           wc: Sirve para contar             -l: cuenta las lineas                useradd: añade un usuario al sistema                      -m: Crea el directorio /home/nombre_usuario                       -s /bin/bash: Asigna una terminal al usuario                       userdel:Elimina un usuario                      -r: Elimina los archivos del home                       -f: Elimina los /home_nombre_usuario                       alias: Muestra los alias de la sesión              alias nombre=’comando’ crea un nuevo alias                unalias nombre_alias: Elimina el alias indicado           tty: Muestra la sesión de shell en la que te encuentras           wget: Descargar archivos de internet desde la linea de comandos           find: Buscar diversos archivos             find donde_empezar_a_bucar [-inum inodo] [-ls]                md5sum: Si parametros realiza la operación matemática para encriptar y te devuelve el hash  que tendrá si se encripta con los datos actuales           stat: Muestra información muy detallada de algún fichero como la creación, acceso, modificación, cambio                      Modificación: Cambios en el contenido                       Cambio: Modificación de permisos propietarios etc                  -f: En vez de mostrar la información del fichero muestra la informacion de filesystem en el que se almacena          tr: Actualiza el contenido de un input que le indiquemos entre comillas por la sustitución. Solo se actualiza la salida por pantalla no el contenido del fichero             tr ‘ ’ ’\\t’                time: time comando time cuenta cuanto tarda en ejecutar el segundo comando           cd: Permite moverse entre directorios                      cd - :Si ponemos solamente - sin ninguna letra o letras nos dirigimos al directorio anterior en el que estábamos                       cd: Si no ponemos argumentos nos vamos al $HOME                        mkfifo: Crea tuberías con nombres mkfifo nombre_tubería           tee: Clona 2 canales pudiendo enviar los flujos de información a 2 sitios normalmente uno por pantalla y otro a un fichero             -a: Anexa y no sobreescribe                : Este comando no hace nada pero siempre retorna un código 0 equivalente a un TRUE           nmtui: Network manager terminal, proporciona una interfaz parecida a las de aptitude para controlar el gestor de red como en la interfaz gráfica           apt-cache show paquete: Muestra información del paquete           sort: Permite ordenar resultados por un criterio como puede ser alfanumérico           uniq: Muestra una única coincidencia           efibootmgr (efi boot management): Muestra las entradas de arranque de la efi, y realiza modificaciones de esta. En windows se conoce como bcdedit (boot configuration disk edit)           wipefs: Borrar filesystem             -af: Fuerza todo el borrado                stress: Estresar la swap                      -m: Numero de trabajos                       –vm-bytes 256M: Unidad de bytes utilizados por los trabajos                       pidof X: Muestra los PID de los procesos con X nombre              pidof -o 111 sshd: Muestra todos los PID de los procesos de sshd menos el 111                nohup:      VARIABLES  Para definir variables se utiliza nombre_variable=valor_variable creamos una variable en memoria si queremos definirla permanentemente podemos añadirla en .bashrc o en un fichero que se ejecute en arranque  cadena=”este texto es el valor”  entero=10  Las variables pueden contener el resultado de la ejecución de un comando   variable=$(comando)  Para ver que hace cada variable, estas se encuentran en el manual de bash man bash          $?: Almacena el código de ejecución del último comando ejecutado: echo $? ▶️ 0 ejecución exitosa, otro código es error           $_: Indica el argumento del último comando ejecutado:                      ls /etc/sshd                       cd $_ = cd /etc/sshd                       $HISTSIZE: Tamaño que puede almacenar el histórico           $PPID: Sirve para ver el id padre           $BASHPID: Muestra el ID de la terminal           $$ : Muestra el PID de la bash actual      Temario  Tema 1  SOFTWARE LIBRE  Un software libre es aquel que cumple con una de las siguientes licencias libres evitando el copyright:          Usar: Poder usarlo con cualquier propósito (Libertad 0)           Aprender y Adaptar: Poder ver y modificar el código (Libertad 1)           Redistribuir: Poder crear copias y distribuirlas (Libertad 2)           Publicar Mejoras: Publicar los cambios del código para que la comunidad aprenda (Libertad 3)      Hay varios tipos de distribuciones:          Independientes: Debian, Rethat, Slackware.           Dependientes: Distribuciones dependientes o basadas en las independientes           Comunidad: Son base de las empresariales y creadas por usuarios de la comunidad: Fedora, OpenSUSE, RedHat           Empresarial: Utilizadas principalmente en el entorno empresarial: Red Hat, Suse, Canonical      Las empresas que utilizan un SO empresarial soportan económicamente a los desarrolladores de la comunidad para que sigan con los SO de la comunidad, estos cambios son adaptados e implementados en los SO empresariales  y estas sacan beneficio con el soporte técnico  Comandos Internos: Comando que ya viene instalado en la shell  Comandos Externos: Comando que no viene con la shell por lo que hay que instalarlo  REPOSITORIOS DEBIAN  Contrib: Paquetes casi libres, que en algun fichero o dependencia cuenta con una licencia no libre  Main: Paquetes completamente libres  Non-free: Paquetes no libres  Non-Free-Firmware: Drivers/modulos no libres  DISTRIBUCIONES DE DEBIAN  old old stable: Penúltima versión estables de debian buster  oldstable: Antigua versión estable de debian, bullseye  stable: Versión estable actual de debian, bookworm  testing: Versión futura todavía no estable de debian, trixie  unstable: Versión de desarrolladores para probar paquetes y demás, SID  experimenta: Mucho más inestable que unstable,  COMANDO [PARÁMETROS] [ARGUMENTOS]  PARÁMETROS: Opciones del comando, Definen como queremos el comando  ARGUMENTOS: Los valores en los que un comando deben realizar una acción  Los comando internos se ejecutan más rápidos que los externos y estos tienen preferencia en caso de haber uno externo e interno con el mismo nombre  PERMISOS  ugousuarios grupo otros  rwxrwxrwxread write execution  TIPOS DE FICHEROS  Cuando realizamos un ls -al la primera letra indica el tipo de fichero que es  -: Ficheros ordinarios  d: Directorios  p: Tuberias con nombres  l: Links tanto softlinks o hardlinks  EXPANSIÓN DE NOMBRES DE FICHERO  Se utiliza para la creación   (COMODINES) Expresiones básicas  Son caracteres de sustitución  *: Representa Uno varios o ningún carácter, cualquiera  ?: Representa a un carácter alfanumérico  [ABC]: Representa un carácter de los que hay dentro de los [], se sitúan todos juntos sin espacios  [A-Z] Representa un carácter dentro de un rango se describe el rango con [] letra o número guion y otra letra o número  [^A-G] Representa un carácter fuera del rango que se indica  [!A-G] Representa un carácter fuera del rango que se especifica   {A,B,C} Representa los 3 caracteres se suele combinar con un prefijo para realizar un eje cartesiano   {a..c}: Representa un rango similar a [a-c]  {A..Z..2} Representa un rango pero el incremento es de 2 en 2  Comodines: Pueden ser utilizado dentro de todos los argumentos que representen ficheros o ruta  \\: Permite cerrar un carácter especial, evitando que se tome como tal: \\* hace que el comodín sea como una letra normal como la A  EXPRESIONES DE NOMBRES COMPLEJAS  Funcionan una vez los ficheros están creados  ?(Expresión): La expresión estará presente 0 o 1 vez  *(Expresión): La expresión estará presente 0 o n veces  +(Expresión): La expresión estará presente 1 o n veces  @(Expresión): La expresión estará presente 1 vez  !(Expresión): La expresión no estaŕa presente  EXPRESIONES LÓGICAS                 PAI, Dependiendo del contexto puede ser una tubería para enlazar comandos y las salidas de estos o como una expresión lógica que simula el OR                          ?(Expresión       Expresión): Una de las expresiones estará presente 0 o 1 vez                          *(Expresión       Expresión): Una de las expresiones estará presente 0 o n veces                          +(Expresión       Expresión): Una de las expresiones estará presente 1 o n veces                          @(Expresión       Expresión): Una de las expresiones estará presente 1 vez                          !(Expresión       Expresión): Una de las expresiones no estaŕa presente           EXPANSIÓN DE COMANDOS  CLAVES PÚBLICAS-PRIVADAS  Al generar 2 claves una pública y otra privada ambas están relacionadas, las públicas la pueden ver todo el mundo y contrastar todos los usuario con sus claves públicas, estas se alojan en máquinas que necesiten accesos como servidores suelen tener .pub  Las claves privadas no tienen extensión suelen aparecer con permisos 600 aconsejable cambiarlos a 400 y está hace contraste con la pública alojada en los servidores, no modificar este archivo ya que la clave dejaría de ser útil  En este archivo se almacenan las claves públicas alojadas en el servidor   Para conectarse con la clave privadas se utiliza ssh -i nombre_clave usuario@IP  Necesario el paquete openssh-server en el servidor y openssh-client en la máquina cliente  CARACTERES DE PROTECCIÓN I  Tabulación, salto línea, espacio  Caracteres de separación  COMILLAS SIMPLES  Eliminan el significado de todos los caracteres especiales, tomando lo de entre comillas como un literal  echo $HOSTNAME ▶️ debian  echo ‘$HOSTNAME’ ▶️ $HOSTNAME  echo ‘Mi equipo se llama ‘$HOME’ &gt;  echo ‘Comillas simples “protegen” a las comillas dobles ▶️ Comillas simples “protegen” a las comillas dobles  echo ‘El valor de \\$PWD es $PWD’ ▶️ El valor de \\$PWD es $PWD  CARACTER \\ SLASH  La barra invertida elimina el significado especial del carácter que le sigel  echo Ficheros del directorio actual: * ▶️ El carácter * sigue teniendo el significado del caracter  echo Ficheros del directorio actual: \\* ▶️ Eliminar el significado del carácter  echo La varra invertida \\\\ protege a la segunda \\ ▶️ La barra invertida \\ protege  COMILLAS DOBLES  Elimina todos los sentidos especiales de todos los caracteres siendo literales menos de los caracteres $ ‘’ $() \\  echo “Well, ins´t that \\”special\\”” ▶️ Well, ins´t that “special”?                 echo “Tienes ‘ls       wc -l’ ficheros en ‘pwd’” ▶️ Tienes 156 ficheros en /dev                          echo “Tienes $(ls       wc -l) ficheros en $(pwd)” ▶️ Tienes 156 ficheros en /dev           echo “El valor de \\$PWD es: $PWD” ▶️ El valor de $PWD es: /dev  OPERADORES  OPERADOR “Y” LÓGICO: &amp;&amp;  comando1 &amp;&amp; comando2  Concatena comandos, es decir ejecuta comando1 si se ejecuta correctamente y no da errores devuelve un código 0 de ejecución exitosa por lo que después ejecuta el comando2, en caso de que el comando1 de algún error devolverá otro código distinto de 0 por lo que no se ejecutará el comando2  EJ:  cd Descargas &amp;&amp; ls -l  Si nos dirigimos a Descargas después listará el contenido de este con ls -l en caso de no poder acceder a la ruta descargas no ejecutara ls -l    OPERADOR “O” LÓGICO                 comando1               comando2           Ejecuta el comando 1 o el comando2 en caso de que comando1 de un codigo diferente de 0 ejecuta el comando2  OPERADOR “;” LÓGICO  Similar al operador logico &amp;&amp; pero este ejecuta todos los comando independientemente del código que devuelva  comando1; comando2; comando3  AGRUPACIÓN DE COMANDO  Puedo agrupar comandos, estos al estar agrupados van a devolver un único codigo de ejecución en vez de uno a uno. Se pueden ejecutar          Los paréntesis(): Se ejecuta en una subshell (shell hijo), esta shell no cuenta con las variables o alias creados manualmente, es una shell “por defecto”           Las llaves{}: Se ejecuta en la shell actual      pstree -sp PID Muestra los procesos padres del proceso indicado  { pwd ; ls ;} &gt; /tmp/salida.txt  GENERACIÓN DE MÚLTIPLES FICHEROS 1  Bucle for   for variable {rango}; do comando;done  for i {0..9};do ‘touch fich$i.txt’;done  Este bucle crea ficheros del 0..9  Bucle for anidados  for i in {A..Z};  do for j in {0..9};  do $(touch fich$i$j.txt);  done;  done;  Podemos abrir un editor de texto en memoria pulsando Ctrl + x + e y crear el bucle con una estructura, este archivo se ejecuta inmediatamente al salir del editor  ALIAS  Comando interno para poner nombre a comandos, pensado para poner nombre a comando muy largo o complejo o el cual vamos a utilizar much  alias nombre=’comando’  Si ponemos un alias con el nombre de un comando del sistema el sistema siempre ejecutará el alias, si alguna vez quiero ejecutar el comando en vez del alias debemos de escapar  \\alias y esto ejecuta el comando en vez del alias  AGRUPACIÓN DE ALIAS  se pueden crear varios alias a la vez  alias \\  nombre=”comando” \\  nombre=”comando”  ENLACES BLANDO / SOFT LINKS  Los enlaces blandos son fichero especiales que contienen la información de una ruta indicada, permisos y propiedades de la ruta.  ln -s ruta_a_la_que_apunta nombre  Un softlink se comporta a lo que apunta, si elimino un softlink no borro el directorio al que apunta y viceversa  Pueden apuntar a directorios y a otros ficheros de otros sistemas de ficheros, es decir con un softlink puedo tener enlaces a un sistemas de archivos diferentes como puede ser una unidad usb, esta es externa a la de mi equipo pero puede utilizar perfectamente un softlink apuntado a este, cuando este se retire el softlink quedará roto ya que no existe la ruta a la que apunta y quedará apuntando a la nada  Los enlaces simbólicos por defecto aparecen con permisos 777 pero verdaderamente se aplican los permisos que tengan el directorio o fichero al que apunta   ENLACES DUROS  / HARDLINK  Asocia 2 o más ficheros teniendo el mismo inodo, estos enlace son una copia exacta del fichero al que apunta, mismo inodo. Si se cambia la ubicación del archivo original, el enlace no se rompe.  ln ruta_a_la_que_apunta nombre  No se pueden hacer hardlink a carpetas o diferentes sistemas de fichero particiones o discos.  Podríamos comprimir o empaquetar la carpeta y después hacer un hardlink a este archivo  Al sobrescribir un fichero se actualizan todos, por lo que hay peligro de sobreescritura al realizar :&gt; hard1 en este caso deja bacio el archivo original y todos los hardlinks  REDIRECCIONES  Son desvíos de flujos de información de un canal con x salida a otro con y salida. La ejecución de comandos devuelven flujos de información con salida por pantalla.  Las redirecciones se utilizan normalmente con los comandos, permiten recuperar el resultado de uno o varios comando y enviarlo a un archivo o provocar la lectura de un archivo por un comando.  Todos los comandos cuenta con 3 descriptores o canales     Entrada estándar o descriptor 0 stdin   Los procesos que esperan la entrada de información por parte del usuario por la entrada estándar desencade una solicitud de lectura en el descriptor 0     Salida estándar o descriptor 1 stdout   Los procesos que necesitan enviar un mensaje al usuario como resultado de la ejecución de un comando tiene que acercar mediante el descriptor 1, está asociado por defecto a la pantalla     Salida de error estándar o descriptor 2   Los procesos necesitan enviar un mensaje de error al usuario como resultado de la ejecución de un comando tiene que hacerlo mediante el descriptor 2, tambien está asociado a la pantalla por defecto  Redirecciones simples  Comando fichero  ls -l &gt;listado.txtó ls -l 1&gt;listado  Si no existe listado.txt se creará, lo primero que hace la shell es crear el fichero y despues la salida de la ejecución de comando la introduce este  ENTRADA0  1 stdaut PANTALLA  2 stderror PANTALLA  Redirecciones dobles  En vez de sobreescribir ficheros, anexa la información al final de este  ls -l » listado.txtóls -l 1» listado.txt  Añadimos los datos de ls -l a listado.txt sin sobre escribir el contenido  Redirecciones de entradas simples  Los comandos que esperan datos o parámetros pueden tambien recibirlos desde un fichero usando &lt;  cat  &lt; fichero.txt  wc &lt; fichero.txtó wc 0&lt; ficher.txt  Las redirecciones no funcionan con todos los comandos, debido a que no todos los comandos son iguales, hay comandos que aceptan entrada de datos otros que solo aceptan la salida de datos y otros ambas tanto salida como entrada de datos  Redirecciones de entradas dobles  HereScript O Here Document, permite la insserción de un texto hasta un punto especificado y el envio de su resultado a un comando o un filtro  tr ‘ ‘ ‘\\t’ &lt;  Ahora introducimos un texto. Al terminar de introducirlo pondremos de nuevo la etiqueta END y el texto se pasará al comando tr  Prioridades  Las redirecciones tienen prioridades unas con otras siendo el orden de más a menos el siguiente &lt;,&gt;,»  Las redirecciones se representan de derecha a izquierda y se crea antes la estructura de redirecciones antes que la ejecución de comandos          Mirar la cantidad de redirecciones           Mirar el tipo de prioridad           En caso de ser iguales de derecha a izquierda      CANALES ESTÁNDARES  ls z*y* &gt; resultado.log 2&gt;&amp;1  &amp;1=Pantalla  primero indica que los errores los va a redireccionar por pantalla, despues indica que el resultado se envie al fichero, la shell comprueba que este fichero exista, sino lo crea y despues procede con la ejecución del comando, en caso de error lo envía por pantalla pero esta a su vez está reenviada al fichero y en caso de no error directamente se envía al fichero  stdin=ls0  1 stdout ➡️ resultado.log  stderr⤴️2   ls z*y* 2&gt; resultado.log 1&gt;&amp;2  En este otro caso es similar al caso de arriba pero esta vez los aciertos son enviados al canal stderr y este está redireccionado a resultado.log  time find / &gt; resultado.log  En este caso los aciertos del comando find son enviados al resultado.log y los errores a la salida por defecto que es la entrada, el comando time va a contar el tiempo de ejecución del comando find desde principio hasta final          Errores en pantalla           wc -l &lt; resultado.log           wc -l 0&lt; resultado.log      time find / 1&gt; resultado.log 2&gt;&amp;1     Todo a resultado.log   wc &lt; fichero.txt &gt; resultado.txt           El contenido de fichero es pasado a wc           El resultado e wc al fichero      ls t* y* 2&gt;/dev/null     Los errores son enviados a /dev/null evitando que aparezcan por pantalla o se almacenen en otros ficheros   ls -l &gt;/dev/null 2&gt;&amp;1     Los errores son reenviados a la pantalla y la pantalla al /dev/null y los aciertos directamente a /dev/null   COMO SABER SI UN COMANDO LLE DE SU ENTRADA STANDAR          Buscando en el manual del comando                      Ver si el argumento file aparece como opcional [file]                       If no file operands are specified, the standard input will be used                       Probando el comando sin dar ningun nombre de archivo como argumento. El comando trar a los datos que lleguen por la entrada estandar. Se finalizará la introducción por entrada estándar, tecleado mediante intro y CRTL + d           Ejemplo, comando wc,cat,grep,sort…      APERTURAS DE CANALES 3-9  TUBERÍAS O PIPELINES                 comando1       comando2           La salida estándar del primer comando es pasado como entrada de datos del segundo  Permiten redireccionar el canal de salida de un comando hacia el canal de entrada de otro comando  Se pueden concatenar múltiples tuberías en la línea de comandos                 **ifconfig eth0       grep 192.168.1.100 n       wc -l**           Tuberías Con Nombres          Las tuberías anteriormente vistas, se crean, se utilizan y se descartan una vez sse destruyen al ejecutar los comandos           Las tuberías con nombre son elementos persistente en el sistema de archivos (ficheros)           Son utilizadas en la comunicación entre procesos para enviar y recibir datos           Los datos permanecerán en la tubería hasta que sean leídos           Poner algo en una tubería con nombre es poner contenido en un extremo de la tubería, el otro extremo de la tubería solo se abrirá cuando…      Para crear una tuberia con nombre se utiliza el comando mkfifo  mkfifo nombre_tubería  ls -al    prw-r–r– nombre_tuberia  ***No se pueden conectar procesos de una máquina con otra a traves de tuberias, solo se pueden utilizar con procesos locales, en caso de querer conectar los procesos de 2 maquinas utilizaremos sockets***  COMANDO TEE  Duplica la salida del canal estandar, redirecciona a varios sitos a la vez como a la pantalla y a un fichero  tee [-a] fichero  stdin-&gt;Tee-&gt;pantalla                             ficheros  Tee solo redirecciona los aciertos, si queremos que tambien redireccione los errores necesitamos indicarselos a mano                 **ls -l x* y* 2&gt;&amp;1       tee fichero.txt**                   Primero mira los redirectores           Monta la redirección por pantalla           Ejecuta el primer comando con las redirecciones por pantalla           La salida del comando es enviada a Tee a traves de una tuberia           Tee reenvia la información a pantalla y al fichero      Esto se utiliza para ver la información tanto de errores como aciertos por pantalla y almacenarla en un fichero  COMANDO XARGS  Utilidad de linea de comandos que lee datos de la entrada estándar y los convierte en argumentos para otros comandos                 **comando1       xargs comando2**           El comando1 proporciona los argumentos a comando2  Vamos a generar un fichero y merter información y enviarselo a xargs  vemos que por defecto actua como un echo  con el parametro -n numero_delimitador podemos modificar el formato de impresión indicando cada cuantos delimitadores de campo queremos crear otra línea          -I {}: Especifica el valor pasado como argumento y lo reemplaza en {} al comando utilizado por xargs                                                             ls               xargs -l {} md5sum {}                                                    En este caso ls lista los archivos y estos son pasados a xargs en la posición de las {} después de eso xargs irá uno a uno con los archivos de ls y pasandolos a md5 en las posición de las {}          -d Se indica los delimitadores de campo por defecto son espacios pero como puede ser el fichero /etc/passwd este no cuenta con espacios y los delimitadores de campo son : por lo que con esta opción se lo podemos indicar -d “:”           -t: Indica que es lo que está haciendo con cada argumento, xargs actúa como un echo pues indica echo argumento y salida de ese echo           -0: Indica que los nombres de ficheros con espacios no son delimitadores de campo sino parte del nombre           -P: Ejecución de procesos en paralelo      xargs cuenta con un buffer donde es capaz de almacenar muchos argumentos mayor que los buffer comunes de los comandos  xargs se suele utilizar con el comando find  echo -e “acl\\nscreen\\ntree”  COMANDO FIND  Permite buscar ficheros mediante criterios  find ruta criterios opciones_visualización  Find tiene relación con el comando xargs find es recursivo, es decir desde la ruta indicada hacia abajo.  Find conforme va buscando y encontrando las coincidencias va devolviendo el resultado y despues sigue buscando          -name: Selección por nombres de ficheros, los criterios de busqueda deben ir entre comillas dobles. Acepta expansión de nombres de ficheros             -iname: No distingue entre mayusculas y minusculas                -type: Selección por tipo de fichero                      b: Fichero de bloque                       c: ficheros tipo carácter                       d: directorios                       f: ordinarios                       l: ficheros tipo simbolico                       p: tuberias con nombre                       s: socket de conexión a red                       -user, -group: Busqueda por el propietario o UID. por grupo de pertenencia del propietario o GUID                      find . -name “p*” -type d -user 1000                       find . -type f -user rafa                       -size: Indica el tamaño de los ficheros buscados, por defecto se emplea como unidad de bloque, 512Bytes                      b: Bloque 512Bytes                       c: Caracter ASCII, 1byte                       w: Una palabra, 2bytes                       k: kilobyte, 1024 Bytes                       + ó -: Los que sea más o menos del tamaño indicado o incluso los que sean mayores a x y menores de y tamaño                                  -size 100c                                    -size 100k                                   -size +5K                                   -size -10k                                   -size 0 (ficheros vacios)                                   -empty                                   -size +10M -size -20M (busca ficheros de más de 10M y menos de 20M)                                           -atime: Fecha de ultimo acceso (access time), puede ser la ultima lectura como último listado ls           -mtime: fecha de ultima modificación (modification time)           -ctime:(change time), ficha de última modificación del numero de inodo, modificación de nombre, cambio de derechos, tamaño etc.      atime, mtime, ctinme trabajan con días (n*24)          +n: Busca valores mayor que n           -n: Busca valores menores que n           n: Busca valores exactamente a n           0: significará el mismo día           1: significará ayer, entre 24 y 48 horas           2: sifnificará antes de ayer, etc                      -mtime +30 -mtime -90 (busqueda entre 30 y 90 días)                       -mmin +120 (busquedas mayores a 120 minutos)                       -newer           -anewer           aaaaaa           -perm: Permite la busqueda por permisos (derechos,SUID,SGID,STICKY BIT). Los permisos se precisoan en octal o en forma simbolica                      find . -perm -220                       find . -perm 664(La diferencia de los guiones es por compatibilidad de diferentes versiones de find)                  Podemos buscar ficheros con operadores     AND, OR,    ***********************          -exec: Ejecuta el comando colocado a continuación con cada una de las coincidencias que encuanete                      find . type f -name “*.jpg” -exe rm -f {} \\;                       El comando asociado a -exec deberá terminar siempre con \\; \\escapa a ; (OBLIGATORIO, PARTE DE LA SINTAXIS DE -exec)                       Sustitución de fichero encontrado pro find con {} delimitados por los argumentos pasados al comando (parecido o similar a xargs)                  ¿Qúe opción es más rápida?  find . -type f -name “*.jpg” -exec rm -rf {} \\;                 find . -type f -name “*.jpg”       xargs -l {} rm -rf           time find . -type f -name “*.jpg” -exec rm -rf {} \\;                 time find . -type f -name “*.jpg”       xargs -l {} rm -rf           COMANDO LOCATE  Busca por nombre en una base de datos     updatedb: Actualizar la base de datos   locate nombre_fichero          -c muestra el número de resultados           -i no distingue entre mayúsculas y minúsculas           –regex: Busca por expresión regular      GREP  Sirve para filtrar por expresiones regulares          grep: Utiliza expresiones regulares básicas para las búsquedas                      -e: Similar a egrep                       -F: Similar a fgrep                        -r: Similar a rgrep                       egrep: Utiliza expresiones regulares extendidas para las búsquedas           fgrep:Obsoletos           rgrep:Oboletos      Su nombre deriva de un comando de texto ed que ten la siguiente forma g/re/p y significa hacer una búsqueda global para las líneas que encajen con la expresión regular  grep [-opciones] Basic.expresion [ficheros]  grep -E [Opciones] Exten.expresion [ficheros]                 **Comando       grep [-opciones] Basic.expresion**           grep [-opciones] Basic.expresion &lt; Fichero  Para comprender mejor cómo funcionan las expresiones regulares, se recomiendo la opción –color=auto que muestra la coincidencia en rojo  En el fichero .bashrc se cargan los siguiente alias comentados  #alias grep = grep –color=auto  EXPRESIONES REGULARES BÁSICAS Y EXTENDIDAS  \\  Escapa el siguiente carácter  Comienzo de línea  $  Final de línea  .  Un caracter cualqueira  [lista de caracteres]  Un caracter de los indicados en la lista  [^Lista de caracteres]  Un carácter de los no indicados en la lista  *  Ningún, uno o varias veces  del carácter o grupo anterior. Igual a {0,}  \\&lt;  Inicio de palabra. Los caracteres válidos son: a-zA-Z0-9  \\&gt;  Final de palabra. Los caracteres válido son: a-zA-Z0-9  \\  Coincidencia con palabra exacta. Los caracteres validos son a-zA-Z0-9  EXPRESIÓN REGULARES BÁSICAS  \\{n\\}  n veces el caracter anterior  \\{n,\\}  Almenos n veces el caracter anterior  \\{n,m\\}  Entre n y m veces el caracter anterior  \\{BRE\\}  Memorización de una BRE(basic expresion regular)  \\1  EXPRESIONES REGULARES EXTENDIDAS  ?  0,1 vez el carácter anterior o grupo anterior, igual a {0,1}  +  D 1 a n veces el caracter o grupo anterior. Igual a  {1,}  {n}  n veces el caracter anterior  {n,m}  Entre n y m veces  CARACTERES POSIX  Con -e podemos incluir varios filtros de de expresioenes  grep -e expresion1 -e expresion2 fichero          -v: Muestra las lineas que no cumplen con la expresion regular           -q: Modo silencioso Indica si la busqueda a sido exitosa o no como la variable $?           -o: Imprime solo las coincidencias      ***************************************  apt-cache show apt-file &gt; apt.txt  RENAME  Sirve para renombrar el nombre de los ficheros no el contenido de estos,  rename /contenido_cambiar/nuevo_contenido/ fichero  Permite el cambio a traves de expresiones regulares basicas o extendidas, muy util combinado con xargs, podemos listas los ficheros con un criterio, y con xargs pasarlos a rename          -v –verbose: Muestra los archivos renombrados exitosamente           -n –nono: No renombra, pero mostraria el resultado de como quedarían los archivos renombrados      SED  sed [-n] acción [fichero, …]  sed [-n] -e acción1 [-e accion2] [fichero, …]  sed -f script-sed [fichero…]   Las acciones se ejecutan en cada línea del fichero. El resultado se mostrará por la salida estándar.  Sed no modificará el fichero origen a no ser que se emplee -i  Sed muestra líneas coincidentes, y además todo el fichero  -n únicamente mostrará líneas seleccionadas por la dirección de la acción  -E permite expresiones regulares extendidas ERE  SED-ACCIÓN  [Dirección[Dirección]]: Sobre que línea voy a aplicar el comando  Comando: Comando propio de sed que se ejecutará  Parametro: Parametro del comando  [Dirección[Dirección]] COMANDO parametro  SED-DIRECCIÓN SIMPLE  Las direcciones simples se suelen utilizar para las primeras líneas o las últimas líneas de un archivos que suelen ser encabezados  Ninguna acción  Dirección simple   Todas las líneas  n  Dirección simple  Linea n  $  Dirección simple  Ultima línea  /BRE/  Dirección simple  Lineas coincidente con la expresión regular  n1,n2accion(p,d)  Dirección multiple  Lineas de la n1 hasta la n2 ambas inclusive  /BRE1/,/BRE2/  Dirección múltiple  La a primera línea tratada será la coincidente con /BRE1/. El tratamiento continúa con el resto de líneas hasta la línea coincidente con /BRE2/, que será la última  -n: Muestra solamente las líneas que coincida  SED-COMANDOS  d (delete)                                     Elimina la primera línea de routertxt.txtcat routertxt.txt           sed ‘1d’ &gt; fichero.txtsed ‘1d’ routertxt.txt &gt; fichero.txt                                Eliminar las diez primeras líneas del routertxt.txtsed ‘1,10d’ routertxt.txt &gt; fichero.txt      Elimina líneas en blancosed ‘/^$/d’ routertxt.txt &gt; textosinblancos.txt   p (print)          sed -n ‘$p’ sources.list           sed -n ‘1,2p’ sources.list           sed -n ‘/^deb.*/p’ sources.list           sed -n ‘/^#/p’ sources.list      = (Mostrar)  ! (negación)     sed -n /^#/!= sources.list   s (sustitución)  s/antiguo/nuevo/[g]  [g]:Opiconal, permite realizar la sustitución sobre toda la línea en caso de que haya varios coincidencias                 router       sed “s/[ ]\\{1,\\}/;/g” &gt; routertxt.txt           sed ‘/-src/s/#//’ sources.list &gt; sincomentarios.txt  w (write)  Escribe en el destino (fichero) las líneas coincidentes de un origen (otro fichero), los ficheros deben de estar creados previamente  sed -n ‘/^#/w destino.txt’ origen.txt  Escribe en los fichero comentarios y codigo del fichero sources.list  sed -n -e ‘/^#/w comentarios’ -e ‘/^[^#]/w código’ sources.list  a (anexar)          Anexa las líneas de texto, después de cada línea especificada           Se puede anexar al pie al fichero             sed -i ‘$a\\Pie’ sed1.txt === echo ‘Pie’ » sed1.txt                Inserción detrás de líneas en blanco             sed ‘/^$/a\\Línea se inserta después de una línea en blanco’ archivo.txt                Anexa Name y descripción después de cada cadena entre []             sed -E -i ‘/^\\[[a-z]+\\]/a\\Name:\\nDescripción:\\n’ sed3.txt           i (insertar)  Similar al comando a (anexar)  pero en vez de la línea siguiente en la linea anterior          sed -i ‘1i\\Encabezado’ sed1.txt Añade una línea de encabezamiento           sed -i ‘/^.*/i\\——seccion———-\\n\\n’ sed1.txt       c (reemplazar)  Reemplaza las líneas especificadas en la dirección por la o las líneas indicadas. Con s haremos cambio parcial sustituyendo una parte     sed -i ‘1c\\Es la nueva línea 1’ comentarios.txt Sustituye la primera línea   CUT  Cambia el formato de un fichero a formato de tabla, es decir por columnas  cut -cColumnas [fichero…]          Una columna es una posición de un carácter en una línea.           El primer carácter está en la columna 1, último en la columna 80      cut -d\\; -F1,3,5-9 fichero.txt  comando od permite ver el valor de cada byte en un fichero          -k número de campo                      -k1,3-bk1.3: Ordena por el tercer carácter del campo1                       bk1,2,3: Por 1º campo, después 3º caracter del 2º campo                       -d Ordenación de diccionario, el criterio son letras números y espacios           -n ordenación numérica           -b ignora espacios al principio del campo           -f no diferencia entre mayusculas o minusculas           -r orden inverso           -tc nuevo delimitador de campo c      TR  No tiene entrada por defecto, debe ser redirigida por otro comando o tuveria     permite sustituir unos caracteres por otros   tr [opciones] original destino  AWK  Lenguaje de script, que se utiliza para el tratamiento en archivos de texto  awk [-F] ‘{acción-awk}’ [ arch1 … archN ]  awk [-F] -f script-awk [ archi1…archN ]  Recibe una relación de argumentos a tratar, si no recibe argumentos, trabaja con la entrada estandard  AWK, VARIABLES  $0  Valor de registro actual, (linea actual)  $1 $2 $3  Referencia al campo en la posición indicada  NF  Número de campos que tiene el registro actual, (numero de palabras de la fila)   $NF  (Ultimo campo)  NR  Indice de registro actual, si estamos en el registro 3 NR será 3  FILENAME  AWK, ACCIÓN-AWK PRINT  Las acciones o instrucciones deben colocarse entre llaves {print}  Muestra los campos 1 y 2, variables $1 y $2 del fichero o flujo introducido  ps aux &gt; awk ‘{print $1,$2}’  awk ‘{print $1,$2}’ procesos.txt  print tambien acepta cadenas como argumento                 **ps aux       awk ‘{print “Usuario: ”$1,”PID: ”$2}’**           En los archivos como /etc/shadow tienen un campo delimitardor de : a diferencia de archivos normales que cuentan con espacios o tabulaciones, debemos de indicarle a awk cual es el delimitador de campo, para ello utilizamos la opción -F “:”                  cat /etc/shadow       awk -F “:” ‘{print “Usuario: ” $1”Shell: ”$7}’                          sudo cat /etc/passwd       awk -F “:” ‘{print “Registro:”NR “\\tUsuario: “$1 “\\t\\t\\tShell: “$7}’           awk utiliza expresiones regulares extendidas que deben estar entre /                                     **awk -F “:” ‘/debian           root/ {print $0}’ passwd.txt**                           Muestra las lineas que tengan debian o root  Correspondencia de un campo con la expresión regular mediante operador ~                                     **sudo cat /etc/passwd           awk -F “:” ‘$7~/bash/{print $0}’**                           El operador ! niega la expresión regular                                      **sudo cat /etc/passwd           awk -F “:” ‘!~/bash/{print $0}’**                           SISTEMAS DE FICHEROS/ARCHIVOS     Bloque: Unidad mínima de almacenamiento con la que trabajan los sistemas de ficheros. En ext4 por defecto el 512 Bytes, es decir cada fichero va a tener si o si ocupado 512 Bytes minimos en el disco   Supuesto practico1     Tamaño del fichero 1 byte , tamaño del bloque 4096 bytes, se estarán desperdiciando 4095   Supuesto practic o2          Disco con 128.000 bloques de 4096 bytes           Tamaño total será 500 Mbytes           Supongamos  128.000 ficheros de 400 bytes           128.000*400=48,83 Mbytes           Disco lleno unicamente con 48,84 Mbytes           Se desperdician 451,17 Mbytes      Dependiendo si vamos a trabajar para uso general o no sabemos cuánto vamos a utilizar exactamente, es mejor utilizar un tamaño de término medio, si sabemos que vamos a trabajar con ficheros que van a ocupar poco espacio es mejor ajustar el tamaño de los bloques para que estos sean también pequeños   HERRAMIENTAS SISTEMAS DE FICHEROS  Algunos comandos calculan el tamaño de los ficheros en bloques: du, df o find  du -h; du  dj -h; df -Th Muestra también tipo fs  df -i Modo inodo, muestra indoso totales usados libres  find -size +4b ficheros de más de 4 bloques   El tamaño de los bloques históricamente era de 512 o 1024 bytes  TABLA DE INODOS  Es una estructura de datos donde se almacenan los inodos utilizados donde estos indican donde se encuentrar quien lo hizo, fecha de creacion y modificación, permisos …  El contenido el cual infoforma un inodo es el siguiente (meta-información)          Tamaño           Identificador del periferico que lo contiene           Su propietario           Su grupo           Su número de inodo           Derechos de acceso           Fecha de ultima modificación del indo           Fecha de uĺtima modificaciḉon del contenido           Fecha de ultimo acceso            Contador de hardlinks           Campos de direcciones de bloques. Contenido propiamente dicho del fichero      DIRECCIONES INDIRECCIONES DE INODOS  El inodo contiene campos de direcciones de bloques          Direcciones que apuntan directamente a los bloques           Direcciones que apuntan a bloques(estructuras de datos) que contienen otros campos de direcciones            Tres campos de indireccion                      Indireccioón simpl                       Indireccion doble                       Indireccion triple                  Ejemplo para sistema de fichero ext2  Diez campos que apuntan a un bloque de datos  Indireccioón simple apunta a 256 direcciones de bloques de datos  Indireccion doble apunta direcciones las cuales apuntan cada una a otras 256 direcciones de bloques de bloques de datos  Indireccion tripole, 256 direcciones las cuales apuntan cada una de ellas a toras 256 direcciones que a su vez apuntan a 256 direcciones de bloques de datos  dumpe2fs  ext3grep  Los catálogos, son los directorios o carpetas, permiten organizar el disco creado una jerarquía   CREACIÓN DE UN SISTEMA DE FICHEROS  mkfs(make filesystem)  mkfs -t tipo opciones perifericos  Donde tipo puede ser ext2, ext3, ext4, vfat …  mkfs -t ext2 /dev/sdc ó mkfs.ext2 /dev/sdc1  mkfs -t ext2 -b 2048 -m 0 -l “Datos” /dev/sdc1  UEFI SHELL  help: muestra la ayuda de comando     -d: Pagina la ayuda   bcfg: Podemos cambiar el orden de arranque de la EFI  map: Mapea los dispositivos  Nombre dispositivo mapeado: Para acceder a un dispositivos especifico  cd: Como debian  ls: Como debian  BINARIOS  los .efi son ejecutables          grubx64.efi: Binario que me vuelve al grub           fbx64.efi:      SWAP   La memoria swap es la utilización de memoria física como ampliación de la memoria ram en caso de que esta esté toda utilizada.  Tamaño recomendados swap:          RAM &lt; 512MBswap doble que la ram           RAM 1GB - 4GB swap del mismo tamaño que la RAM           RAM &gt; 4GBswap de 4GB      La swap es necesaria si queremos habilitar la hibernación del equipo. La info cargada en memoria es cargada en swap al apagar el sistema cesando toda actividad en el equipo. En el siguiente incio la información será restaurada  Se puede indicar en qué momento de se activa el swap, esto es gestionado por el kernel.  /proc/sys/vm/swappiness este archivo conetien el valor a restar del 100 % de la memoria para la activación de la swap EJ: en el fichero contiene el valor 60 100-60 = 40% la swap se activara al momente de que la ram este al 40%  Para hacerlo persistente editamos el fichero /etc/sysctl.conf este fichero contiene configuraciones que interaccionan con el kernel, y añadimos el valor vm.swappiness=VALOR  mkswap /dev/???? -L label  Se puede crear un fichero actuando como dispositivo de bloque simulando la swap, este fichero es menos efectivo que la propia partición swap  dd if=/dev/zero of/swap bs=1024 count 65536  mkswap /swap  chmod 600 /swap  swapon -v /swap                 free       grep swap           /etc/fstab  /swapswapswapdefaults00  ZRAM  Utiliza part de la memoria RAM  RAM es más rápida y eficiente que un disco, pratición o un fichero   La memoria utilizada, estará en modo comprimido es por ello que necesitamos de procesador  apt install zram-tools  Fichero de configuración: /etc/default/zramswap          Grado de compresión                      speed:lz4 &gt;zstd&gt;lz0                       compression:zstd &gt;lzo &gt;lz4                       ALGO=lz4                  No es compatible utilizar size y percent al mismo tiempo, además de habilitar un servicio  Comprobamos que el servicio esta activo,  systemctl muestra todos los servicios y actua como un less  Despues systemctl status nombre del servicio  swapon -s para ver el estado   si queremos evitar que se monte la partición swap y utilizar la zramswap creda debemos de comentar la linea de la partición swapt /etc/fstab y en el proximo arranque ya no estará en uso  JOURNALCTL  Ver los archivos logs del sistema  journalctl -u systemd-journald.service -f          -u indicamos el servicio           -f      GRUB EFI INITRAMFS          fbx64.efi: Ejecutable para acceder al firmware (EFI/BIOS)           grubx64: Ejecutable para el grub firmado por debian/linux           shimx64.efi: Ejecutable para el grub firmado por microsoft           mmx64.efi: Nos dirije al gestor de firma de los kernel de arranque      El gestor de arranque a la hora de ejecutar un sistema utiliza principalmente 2 cosas          Kernel: Todo lo fundamental para el arranque. Si el kernel está mal necesitas es más difícil de reparar(kernel panic). Hay un shell con comandos específicos para el kernel           Initramfs: Contiene módulos de arranque del kernel, cosas no fundamentales pero que complementa al kernel con el objetivo de arrancar el sistema. Si el initramfs esta mal             initrd&gt; Esta shell cuenta con funciones  para poder            El grub cuenta con su propia shell          ls: vemos los dispositivos de bloque y el particionado             ls (hd0,gpt1)/ Vemos el contenido de la partición                insmod linux: Importamos módulos de arranque,            linux (hd0,gpt3)/vmlinuzXXXXX root=/dev/vda3: Importamos el kernel y le indicamos donde esta el sistema de ficheros, necesario identificar el tipo de dispositivos que se utiliza            initdr (hd0,gpt3)/intramfsXXXXX: Indicamos el initramfs, misma versión que el kernel           boot: Arrancamos con los cambios hechos, puenteando el grub      Cuando llegamos al grub e seleccionamos un kernel de arranque y no arranca pero con otro si, es posible que el kernel o el initramfs puede que esten dañados, para solucionarlo:     initramfs: Utilizando update-initramfs -u version podemos actualizar el initramfs   PROCESOS  PCB: Bloque de control de procesos, es una variable que cuenta con varios campos que almacena como puede ser el ID del proceso, o el PID.  El sistema trabaja con los identificadores de procesos y no con nombres.  Para ver los procesos podemos utilizar ps aux, el primer proceso y el padre de todos es el proceso init  con la variable $$ puedo ver el proceso de la bash actual en la que me encuentro  Ctrl + z envia a dormir (pausa en segundo plano) un proceso y con Ctrl + c lo elimino  Otra forma para enviarlo a segundo plano es utilizar &amp; para ello  comando &amp;  Con el comando fg(foreground) podemos traer los procesos de segundo plano a primer plano ej  fg %numero_de_job  El comando pidof, identifica los procesos de un determinado comando  SESIONES  Las sesiones son dependientes de las TTY  donde estas tienen una configuración, variables permisos usuarios… definidos anteriormente, una sesión puede tener varias ventanas asociadas a esta.  Los procesos generados en la sesión siguen en ejecución aun después de salir/ esta  Las regiones de una sesión es parecido a dividir la pantalla de terminator y estas regiones tienen ventanas comunes  Utilizando screen puedo crear sesiones.          screen -S nombre           screen -ls (ver sesiones)      Dentro de las sesiones utilizando la combinación de Ctrl + a  y a continuación Shift + “ muestro las ventanas de las sesiones  Si la sesión es attached indica que estamos en esa sesión, para salir de la sesión utilizamos Ctrl + a y despues pulsamos d (detached) y para reconectarmos:     screen -r [nombre_session]   Con Ctrl + a y despues pulsamos A renombramos la ventana  Ctrl + a y despues pulsamos c nueva ventana  Ctrl + a y despues pulsamos S nueva region de la sesion                 Con **Ctrl + a pulsmos       ** se crea una region verticalmente           Con CTRL + a y pulsamos k borramos la ventana y pulsando X la region  CTRL + a y pulsamos : podemos ejecutar ciertos comandos para crear sesiones multiusuario  multiuser on  useradd usuario  aclchg usuario + permisos[r/w] nombre_ventana “#” &lt;- todas las ventanas  screen -x usuario/IDsesion  HAY QUE DARLES PERMISOS   chmod u+s /usr/bin/screen  chmod 755 /run/screen  SCRIPT  #!/ruta/intérprete  El #! se denomina “seban” para muchos scripts es necesario pero hay algunos como el .bashrc en el que no son necesarios  Los intérpretes pueden ser bash sh php python … lo más estándar es #!/usr/bin/env nombre_interprete   Para crear un script partimos de un fichero normal y corriente que tiene que tener el permiso de ejecución en función del metodo de ejecución que utilicemos y podemos editarlo con cualquier procesador o editor de texto como puede ser el Visual Studio o el editor por defecto del sistema  Para ejecutar un script podemos utilizar varios métodos          /ruta/absoluta o relativa /script           intérprete /ruta/script           source /ruta/script           . /ruta/script      Con el método de intérprete /ruta/script no es necesario que el archivo tenga permisos de ejecución y este se va a ejecutar en una shell hija y se puede dar el caso que las variables que se tengan en la shell principal, no se encuentren en la shell hija o no contengan el mismo valor  Con el método /ruta/absoluta o relativa /script el fichero si necesita permisos de ejecución y se ejecutará en una shell hija.  El sistema busca los binarios en ciertas rutas que se pueden ver en la variable $PATH para modificarla.  Si utilizamos export podemos exportar variables de la shell padre a la shell hija y modificarla a nuestro antojo. Hay que tener en cuenta que las variables cambian por lo que tenemos que tener el valor de la original en caso de querer restaurarla:  #!/bin/bash  export oldpath=$(echo $PATH) Con esto guardamos el valor original  export $PATH=$PATH:/nueva/ruta Añadimos una ruta  export $PATH=oldpath Volvemos a poner el valor original  La ejecución con el comando source no necesita de permisos de ejecución y se ejecuta en la shell actual   La ejecución con el comando . ruta_absoluta_o_relativa tampoco necesita de permiso de ejecución y se ejecuta en la shell actual  Para comentar los scripts hay varias formas:          Utilizando # comenta una sola línea           Utilizando «&lt; NOMBRE_ETIQUETA comentario NOMBRE_ETIQUETA       LAS SHELLS HIJAS NO SON IGUALES QUE LAS SUBSHELL  UNA SHELL HIJA NO TIENE QUE RECONOCER LAS VARIABLES DEL PADRE, PERO UNA SUBSHELL SI RECONOCE LAS VARIABLES DEL PADRE  PASO DE ARGUMENTOS AL SCRIPT  Los argumentos se pasan a través de las variables posicionales          $0 Nombre del script           $1, $2, $3 … $9 los nueve primeros argumentos           ${10}, {11}…           $# número de argumentos pasados al script           $@, $* Todos los argumentos, empezando por $1           $$ PID del shell que interpreta el script           $! PID del último comando ejecutado en segundo plano desde el script           $? código de estado de ejecución del último comando      A las funciones tambien se le pueden pasar estos argumentos hay que saber diferernciar entre los argumentos a funciones, script, o el comando set  El comando shift permite desplazar argumentos a n posiciones a la izquierda ej:      $1     $2  script.sh arg1 arg2  shift 1                    $1  script.sh arg2  La funcionalidad es recorrer los argumentos de forma secuencial y pudiendo hacer referencia a una unica variable posicional casi siempre en vez de hacer referencia a $8 con shift podemos indicarle que se desplace los argumentos 7 veces a la izquierda de modo que al querer hacer referencia a $8 hacemos referencia a $1  ENTRADA DE DATOS MANUALMENTE AL SCRIPT  Para introducir datos manualmente utilizamos el comando read y la información se almacena en una variable  read variable_dato  read var1  read var1 var2          -p “OUTPUT” Con esta opción podemos indicarle un texto que será visible para introducir los datos, como si fuera un input de python           -s: Modo silencioso, no muestra el input que se solicita           -n num_caracteres: Indicamos el numero especifico de caracteres           -t segundos: Indicamos el tiempo de espera máximo en segundos      ESTRUCTURA CONDICIONAL IF  Hay varias formas de especificar una condición, ambas funcionan por igual y son comandos internos          test ó [ ]           [[ ]]      sintaxis:     test expresion ó [ expresión ]   Condiciones sobre cadenas de texto  Igualdad          [ “$a”=”$b” ]           [ “$a”==”$b” ]      Desigualdad     [ “$a”!=”$b” ]   [ “$a” \\&lt; “$b” ]                         Orden alfabético  [ “$a” \\&gt; “$b” ]                         Orden alfabético inverso  [ -z “$a” ]ó test -z “$a”             variable es vacía, cierto  [ -n “$a” ]ó test -n “$a”             contiene algo, cierto  Condiciones sobre numericos  [ $a -eq $b ]ó test $a -eq $bIgualdad  [ $a -ne $b ]ótest $a -ne $bDesigualdad  [ $a -gt $b ]    ó test $a -gt $bMayor que  [ $a -lt $b ]    ótest $a -lt $bMenor que  [ $a -ge $b ]ó test $a -ge $bMayor o igual que  [ $a -le $b ]    ótest $a -le $bMenor o igual que  Condiciones sobre ficheros  [ -e nombre fichero ] existencia  [ -f nombre fichero ] true si es fichero ordinario  [ -s nombre fichero ] true si es fichero no vacío (0 bytes)  [ -d nombre fichero ] true si es directorio  [ -b nombre fichero ] true si es dispositivo de bloques  [ -c nombre fichero ] true si es dispositivo de caracteres  [ -r nombre fichero ] true si tiene permiso de lectura  [ -x nombre fichero ] true si tiene permiso de ejecución  [ -w nombre fichero ] true si tiene permiso de escritura  test -e nombre fichero  true si existencia  test -f nombre fichero true si es fichero ordinario  test -s nombre fichero true si  es fichero no vacío  test -d nombre fichero  true si es directorio  test -b nombre fichero  true si  es dispositivo de bloques  test -c nombre fichero  true si  es dispositivo de caracteres  test -L nombre fichero  true si  es enlace simbólico  test -r nombre fichero true si tiene permiso de lectura  test -x nombre fichero  true si  tiene permiso de ejecución  test -w nombre fichero true si  tiene permiso de escritura  OPERADORES LÓGICOS  [ “EXPR1”-a”expr2” ] AND entre expr1 y expr2  [ “expr1”-o”expr2” ] OR entre expr1 y expr2  [ !expr1 ] NOT expr1  AGRUPACIONES  Permite priorizar los operadores utilizando () y estos hay que escaparlos  En el ejemplo de abajo primero comprueba la existencia -e del $dir1 o -o la existencia -e $dir2 despues comprueba si $fich1 tiene permiso de escritura -w y se tiene concatena ambas estructuras con -a que es el operador basico and  [ -w $fich1 -a \\(-e $dir1 -o -e $dir2\\) ]  COMANDO [[ ]]  Versión avanzada de test o []                 Los operadores lógicos and y or cambian a &amp;&amp; y **               **            COMPARACIÓN DE CADENAS MEDIANTE PATRON  Podemos comparar con expresiones regulares propias, para ello tenemos que empezar la comparación con una viguerilla  ~   ESTRUCTURA IF  1º  IF COMANDO  THEN  COMANDOS  FI  ———————————–  2º  IF COMANDO  THEN  COMANDOS  ELSE  COMANDOS  FI  —————————–  3º  IF COMANDO  THEN  COMANDOS  ELIF COMANDO2  THEN  COMANDOS  ELSE  COMANDOS  FI  Hay otra opción, cuando el comando es uno podemos utilizar   comando1 &amp;&amp; comando2 si el comando 1 devuelve codigo 0 se ejecuta el comando 2 y queda de mejor forma en el codigo  Tambien se puede utiliza la siguiente sintaxis:  if comando1; then  comando2  fi  LIBRERAS  Conjunto de funciónes que se pueden implementar en los scripts para la reutilización de codigo. Mediante source o . se invoca la librería:          libreria=/home/debian           source $libreria/funciones           nombre_funcion_libreria      Las funciones tambien se pueden utilizar en una línea          function nombre { comandos }           function nombre {                      comandos                       }                  Podemos editar las funciones escritas en la propia terminal con control + x + control + e  getops  BUCLES  for “variable”  in “recorrido”;    do    comandos;    done  while condición;  do    comandos  ;done  SENTENCIA CASE  Se utiliza principalmente para realizar múltiples comparaciones con una variable o expresión y ejecutar diferentes acciones segun el resultado de estas comparaciones, se suele utilizar en la creación de menús  CASE variable IN  patron)  bloque1  ;;  patron)  bloque2  ;;  patron)  bloque3  ;;  *)indica bloque por defecto en caso de que ningun patron se cumpla  bloque por defecto  ;;  esac  case “uno” in  u)  echo “u”  ;;  u?o)  echo “u?o”  ;;  u*)  echo “u*”  ;;  *)  echo “ninguno”  ;;  esac  Ficheros  La lectura de un fichero se realiza mediante read  read lee de la entrada estandar,  Cuando lee una linea devuelve verdadero  Cuando llega al final del fichero devuelve falso  while read linea;  do  (( contador ++ ))  echo “Linea numero $contador contenido: $linea”  ;done  Otra opción para leer un fichero es:                 **cat fichero.txt       while read primera segunda tercera cuarta; do**               “echo el contenido de las variables son: $primera $segunda $tercera $cuarta” »origen.txt  ;done  Origen.txt va a ir almacenando el contenido de las variables  DEPURACIÓN DE SCRIPTS  Imprime cada una de las instrucciones, bhay varias opciones:          Utilizar -x en la cabecera del scritp#!/bin/env -S bash -x           En la invocaciónbash -x script.sh            Utilizando el comando set dentro del script, este comando depura el fragmento de codigo que se encuentra entre set -x y set +x      Podemos utilizar -u para indicar un error en caso de que haya una variable no definida                 **bash -u scrip.sh               set -u set +u**           bash -n no ejecuta el script sino que simplemente chequea la sintaxis  bash -v devuelve el error y la linea en la que se encuentra  El comando shellcheck analiza el codigo y te recomienda buenas prácticas  DIALOG   dialog –inputbox “Título” 20 10  USUARIO ESPECIALES  con chmod 0=fichero eliminamos todos los permisos  Máscara de permisos:  WINDOWS  wpeutil sirve para ejecutar ciertos comandos en el entorno de preisntalación  Las rutas de comandos estan en C:\\Windows\\System32  bcdboot c:\\Windows /s f: /f UEFI  Para comprobar que unn sistema windows esta funcionano en UEFI O BIOS podemos mirar la información de sistema:  Para elevar privilegios en el cmd de windows para ser administradores utilizamos el comando          runas             /?: Muestra la ayuda           Si tenemos la particion de recuperación creada, hay una ruta C:\\Windows\\system32\\recovery   El contenido de este directorio esta oculto , los podemos visualizar con dir y una opcion  En este directorio hay un archivo winrec.wim indica que la particion de recuperación no esta activada  Con reagentc /info podemos verificar si la partición esta activada  reagentc /disable /enable se puede activar o desactivar  Podemos entrar en modo recuperación sin usar una ISO siempre que tengamos el sistema operativo funcional          shift + reiniciar           Configuración de windows&gt;actualización y seguridad&gt; recuperacion           shutdown -o -r -t 10                      -r reboot                       -t tiempo                       -o va al menu de arranque avanzado                  Si pulsamos en configuración de inicio y después en reiniciar, a posterior nos aparecera un menu de arranque para seleccionar el modo seguro  bcdedit editor de configuración de arranque  Comando que permite modificar el gestor de arranque de windows  bcdedit /?  El archivo original que se modifica con bcdedit se encuentra F:\\EFI\\Microsoft\\Boot\\BCD  Este archivo tambien es el generado o modificado por bcdboot  Si hay algun problema con el sistema utlizamoso  sfc /scannow en caso de que este comando no funcione utilizamos el siguiente:          dism /online /Cleanup-image /checkhealt /online si el sistema está arrancado            dism /image:d: /cleanup-image /restorehealth /sourtce:e:\\windows      POWERSHELL  Todo comando de powershell está compuesto por un verbo y un nombre en singular  Para actualizar la ayuda de un comando of funcion hay que actualizar el modulo para saber el modulo del comando puedo utilizar get-command nombre_comando  La ayuda de la powershell 7 (nueva version de powershell) la ayuda esta en la nube          winget: Gestor de paquetes desde linea de comandos de windows, no tan avanzado como los gestor de paquetes de gnu-linux           measure-object: Cuenta los objetos de salida de los comandos"
  }
  
]

